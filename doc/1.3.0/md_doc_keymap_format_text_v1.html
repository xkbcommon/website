<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libxkbcommon: The XKB keymap text format, V1</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libxkbcommon
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The XKB keymap text format, V1 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document describes the <code>XKB_KEYMAP_FORMAT_TEXT_V1</code> keymap format, as implemented by libxkbcommon.</p>
<p>NOTE: This document is ever incomplete. Some additional resources are:</p>
<ul>
<li><a href="https://web.archive.org/web/20190724015820/http://pascal.tsu.ru/en/xkb/">Ivan Pascal's XKB documentation</a></li>
<li><a href="https://www.charvolant.org/doug/xkb/html/index.html">An Unreliable Guide to XKB Configuration</a></li>
<li><a href="https://wiki.archlinux.org/index.php/X_keyboard_extension">ArchWiki XKB page</a></li>
</ul>
<p>A keymap consists of a single top-level <code><a class="el" href="structxkb__keymap.html" title="Opaque compiled keymap object.">xkb_keymap</a></code> block, underwhich are nested the following sections.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
The &lt;tt&gt;xkb_keycodes&lt;/tt&gt; section</h1>
<p>This is the simplest section type, and is the first one to be compiled. The purpose of this is mostly to map between the hardware/evdev scancodes and xkb keycodes. Each key is given a name by which it can be referred to later, e.g. in the symbols section.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Keycode statements</h2>
<p>Statements of the form: </p><pre class="fragment">&lt;TLDE&gt; = 49;
&lt;AE01&gt; = 10;
</pre><p> The above would let 49 and 10 be valid keycodes in the keymap, and assign them the names <code>TLDE</code> and <code>AE01</code> respectively. The format <code>&lt;WXYZ&gt;</code> is always used to refer to a key by name.</p>
<p>[The naming convention <code>&lt;AE01&gt;</code> just denotes the position of the key in the main alphanumeric section of a standard QWERTY keyboard, with the two letters specifying the row and the two digits specifying the column, from the bottom left.]</p>
<p>In the common case this just maps to the evdev scancodes from <code>/usr/include/linux/input.h</code>, e.g. the following definitions: </p><pre class="fragment"> #define KEY_GRAVE            41
 #define KEY_1                2
</pre><p> correspond to the ones above. Similar definitions appear in the xf86-input-keyboard driver. Note that in all current keymaps there's a constant offset of 8 (for historical reasons).</p>
<p>If there's a conflict, like the same name given to different keycodes, or same keycode given different names, it is resolved according to the merge mode which applies to the definitions.</p>
<h2><a class="anchor" id="autotoc_md24"></a>
Alias statements</h2>
<p>Statements of the form: </p><pre class="fragment">alias &lt;MENU&gt; = &lt;COMP&gt;;
</pre><p> Allows to refer to a previously defined key (here <code>&lt;COMP&gt;</code>) by another name (here <code>&lt;MENU&gt;</code>). Conflicts are handled similarly to keycode statements.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
LED name statements</h2>
<p>Statements of the form: </p><pre class="fragment">indicator 1 = "Caps Lock";
indicator 2 = "Num Lock";
indicator 3 = "Scroll Lock";
</pre><p> Assigns a name to the keyboard LED (AKA indicator) with the given index. The LED may be referred by this name later in the compat section and by the user.</p>
<h1><a class="anchor" id="autotoc_md26"></a>
The &lt;tt&gt;xkb_types&lt;/tt&gt; section</h1>
<p>This section is the second to be processed, after <code>xkb_keycodes</code>. However, it is completely independent and could have been the first to be processed (it does not refer to specific keys as specified in the <code>xkb_keycodes</code> section).</p>
<p>This section defines key types, which, given a key and a keyboard state (i.e. modifier state and group), determine the shift level to be used in translating the key to keysyms. These types are assigned to each group in each key, in the <code>xkb_symbols</code> section.</p>
<p>Key types are called this way because, in a way, they really describe the "type" of the key (or more correctly, a specific group of the key). For example, an ordinary keymap will provide a type called <code>KEYPAD</code>, which consists of two levels, with the second level being chosen according to the state of the Num Lock (or Shift) modifiers. Another example is a type called <code>ONE_LEVEL</code>, which is usually assigned to keys such as Escape; these have just one level and are not affected by the modifier state. Yet more common examples are <code>TWO_LEVEL</code> (with Shift choosing the second level), <code>ALPHABETIC</code> (where Caps Lock may also choose the second level), etc.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Type definitions</h2>
<p>Statements of the form: </p><pre class="fragment">type "FOUR_LEVEL" { ... }
</pre><p> The above would create a new type named <code>FOUR_LEVEL</code>. The body of the definition may include statements of the following forms:</p>
<h3><a class="anchor" id="autotoc_md28"></a>
&lt;tt&gt;level_name&lt;/tt&gt; statements</h3>
<pre class="fragment">level_name[Level1] = "Base";
</pre><p> Mandatory for each level in the type.</p>
<p>Gives each level in this type a descriptive name. It isn't used for anything.</p>
<p>Note: A level may be specified as Level[1-8] or just a number (can be more than 8).</p>
<h3><a class="anchor" id="autotoc_md29"></a>
&lt;tt&gt;modifiers&lt;/tt&gt; statement</h3>
<pre class="fragment">modifiers = Shift+Lock+LevelThree;
</pre><p> Mandatory, should be specified only once.</p>
<p>A mask of real and virtual modifiers. These are the only modifiers being considered when matching the modifier state against the type. The other modifiers, whether active or not, are masked out in the calculation.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
&lt;tt&gt;map&lt;/tt&gt; entry statements</h3>
<pre class="fragment">map[Shift+LevelThree] = Level4;
</pre><p> Should have at least as many mappings as there are levels in the type.</p>
<p>If the active modifiers, masked with the type's modifiers (as stated above), match (i.e. equal) the modifiers inside the <code>map[]</code> statement, then the level in the right hand side is chosen. For example, in the above, if in the current keyboard state the <code>Shift</code> and <code>LevelThree</code> modifiers are active, while the <code>Lock</code> modifier is not, then the keysym(s) in the 4th level of the group will be returned to the user.</p>
<h3><a class="anchor" id="autotoc_md31"></a>
&lt;tt&gt;preserve&lt;/tt&gt; statements</h3>
<pre class="fragment">map[Shift+Lock+LevelThree] = Level5;
preserve[Shift+Lock+LevelThree] = Lock;
</pre><p> When a key type is used for keysym translation, its modifiers are said to be "consumed". For example, in a simple US keymap, the "g" "g" key is assigned an ordinary <code>ALPHABETIC</code> key type, whose modifiers are Shift and Lock; then for the "g" key, these two modifiers are consumed by the translation. This information is relevant for applications which further process the modifiers, since by then the consumed modifiers have already "done their part" and should be masked out.</p>
<p>However, sometimes even if a modifier had already affected the key translation through the type, it should <em>not</em> be reported as consumed, for various reasons. In this case, a <code>preserve[]</code> statement can be used to augment the map entry. The modifiers inside the square brackets should match one of the map[] statements in the type (if there is no matching map entry, one mapping to Level1 is implicitly added). The right hand side should consists of modifiers from the type's modifiers; these modifiers are then "preserved" and not reported as consumed.</p>
<h1><a class="anchor" id="autotoc_md32"></a>
The &lt;tt&gt;xkb_compat&lt;/tt&gt; section</h1>
<p>This section is the third to be processed, after <code>xkb_keycodes</code> and <code>xkb_types</code>.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Interpret statements</h2>
<p>Statements of the form: </p><pre class="fragment">interpret Num_Lock+Any { ... }
interpret Shift_Lock+AnyOf(Shift+Lock) { ... }
</pre><p> The <code>xkb_symbols</code> section (see below) allows the keymap author to perform, among other things, the following things for each key:</p>
<ul>
<li>Bind an action, like SetMods or LockGroup, to the key. Actions, like symbols, are specified for each level of each group in the key separately.</li>
<li>Add a virtual modifier to the key's virtual modifier mapping (vmodmap).</li>
<li>Specify whether the key should repeat or not.</li>
</ul>
<p>However, doing this for each key (or level) is tedious and inflexible. Interpret's are a mechanism to apply these settings to a bunch of keys/levels at once.</p>
<p>Each interpret specifies a condition by which it attaches to certain levels. The condition consists of two parts:</p>
<ul>
<li>A keysym. If the level has a different (or more than one) keysym, the match fails. Leaving out the keysym is equivalent to using the <code>NoSymbol</code> keysym, which always matches successfully.</li>
<li><p class="startli">A modifier predicate. The predicate consists of a matching operation and a mask of (real) modifiers. The modifiers are matched against the key's modifier map (modmap). The matching operation can be one of the following:</p><ul>
<li><code>AnyOfOrNone</code> - The modmap must either be empty or include at least one of the specified modifiers.</li>
<li><code>AnyOf</code> - The modmap must include at least one of the specified modifiers.</li>
<li><code>NoneOf</code> - The modmap must not include any of the specified modifiers.</li>
<li><code>AllOf</code> - The modmap must include all of the specified modifiers (but may include others as well).</li>
<li><code>Exactly</code> - The modmap must be exactly the same as the specified modifiers.</li>
</ul>
<p class="startli">Leaving out the predicate is equivalent to using <code>AnyOfOrNone</code> while specifying all modifiers. Leaving out just the matching condition is equivalent to using <code>Exactly</code>.</p>
</li>
</ul>
<p>An interpret may also include <code>useModMapMods = level1;</code> - see below.</p>
<p>If a level fulfils the conditions of several interprets, only the most specific one is used:</p>
<ul>
<li>A specific keysym will always match before a generic <code>NoSymbol</code> condition.</li>
<li>If the keysyms are the same, the interpret with the more specific matching operation is used. The above list is sorted from least to most specific.</li>
<li>If both the keysyms and the matching operations are the same (but the modifiers are different), the first interpret is used.</li>
</ul>
<p>As described above, once an interpret "attaches" to a level, it can bind an action to that level, add one virtual modifier to the key's vmodmap, or set the key's repeat setting. You should note the following:</p>
<ul>
<li>The key repeat is a property of the entire key; it is not level-specific. In order to avoid confusion, it is only inspected for the first level of the first group; the interpret's repeat setting is ignored when applied to other levels.</li>
<li>If one of the above fields was set directly for a key in <code>xkb_symbols</code>, the explicit setting takes precedence over the interpret.</li>
</ul>
<p>The body of the statement may include statements of the following forms (all of which are optional):</p>
<h3><a class="anchor" id="autotoc_md34"></a>
&lt;tt&gt;useModMapMods&lt;/tt&gt; statement</h3>
<pre class="fragment">useModMapMods = level1;
</pre><p> When set to <code>level1</code>, the interpret will only match levels which are the first level of the first group of the keys. This can be useful in conjunction with e.g. a <code>virtualModifier</code> statement.</p>
<h3><a class="anchor" id="autotoc_md35"></a>
&lt;tt&gt;action&lt;/tt&gt; statement</h3>
<pre class="fragment">action = LockMods(modifiers=NumLock);
</pre><p> Bind this action to the matching levels.</p>
<h3><a class="anchor" id="autotoc_md36"></a>
&lt;tt&gt;virtualModifier&lt;/tt&gt; statement</h3>
<pre class="fragment">virtualModifier = NumLock;
</pre><p> Add this virtual modifier to the key's vmodmap. The given virtual modifier must be declared at the top level of the file with a <code>virtual_modifiers</code> statement, e.g.: </p><pre class="fragment">virtual_modifiers NumLock;
</pre> <h3><a class="anchor" id="autotoc_md37"></a>
&lt;tt&gt;repeat&lt;/tt&gt; statement</h3>
<pre class="fragment">repeat = True;
</pre><p> Set whether the key should repeat or not. Must be a boolean value.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
LED map statements</h2>
<p>Statements of the form: </p><pre class="fragment">indicator "Shift Lock" { ... }
</pre><p> This statement specifies the behavior and binding of the LED (AKA indicator) with the given name ("Shift Lock" above). The name should have been declared previously in the <code>xkb_keycodes</code> section (see LED name statement), and given an index there. If it wasn't, it is created with the next free index.</p>
<p>The body of the statement describes the conditions of the keyboard state which will cause the LED to be lit. It may include the following statements:</p>
<h3><a class="anchor" id="autotoc_md39"></a>
&lt;tt&gt;modifiers&lt;/tt&gt; statement</h3>
<pre class="fragment">modifiers = ScrollLock;
</pre><p> If the given modifiers are in the required state (see below), the LED is lit.</p>
<h3><a class="anchor" id="autotoc_md40"></a>
&lt;tt&gt;whichModState&lt;/tt&gt; statement</h3>
<pre class="fragment">whichModState = Latched+Locked;
</pre><p> Can be any combination of:</p>
<ul>
<li><code>base</code>, <code>latched</code>, <code>locked</code>, <code>effective</code></li>
<li><code>any</code> (i.e. all of the above)</li>
<li><code>none</code> (i.e. none of the above)</li>
<li><code>compat</code> (legacy value, treated as effective)</li>
</ul>
<p>This will cause the respective portion of the modifier state (see <code>struct <a class="el" href="structxkb__state.html" title="Opaque keyboard state object.">xkb_state</a></code>) to be matched against the modifiers given in the <code>modifiers</code> statement.</p>
<p>Here's a simple example:</p>
<p>indicator "Num Lock" { modifiers = NumLock; whichModState = Locked; };</p>
<p>Whenever the NumLock modifier is locked, the Num Lock LED will light up.</p>
<h3><a class="anchor" id="autotoc_md41"></a>
&lt;tt&gt;groups&lt;/tt&gt; statement</h3>
<pre class="fragment">groups = All - group1;
</pre><p> If the given groups are in the required state (see below), the LED is lit.</p>
<h3><a class="anchor" id="autotoc_md42"></a>
&lt;tt&gt;whichGroupState&lt;/tt&gt; statement</h3>
<pre class="fragment">whichGroupState = Effective;
</pre><p> Can be any combination of:</p>
<ul>
<li><code>base</code>, <code>latched</code>, <code>locked</code>, <code>effective</code></li>
<li><code>any</code> (i.e. all of the above)</li>
<li><code>none</code> (i.e. none of the above)</li>
</ul>
<p>This will cause the respective portion of the group state (see <code>struct <a class="el" href="structxkb__state.html" title="Opaque keyboard state object.">xkb_state</a></code>) to be matched against the groups given in the <code>groups</code> statement.</p>
<p>Note: the above conditions are disjunctive, i.e. if any of them are satisfied the LED is lit.</p>
<h1><a class="anchor" id="autotoc_md43"></a>
The &lt;tt&gt;xkb_symbols&lt;/tt&gt; section</h1>
<p>NOTE: The documentation of this section is incomplete.</p>
<p>This section is the fourth to be processed, after <code>xkb_keycodes</code>, <code>xkb_types</code> and <code>xkb_compat</code>.</p>
<p>Statements of the form: </p><pre class="fragment">xkb_symbols "basic" {
    ...
}
</pre><p> Declare a symbols map named <code>basic</code>. Statements inside the curly braces only affect the symbols map.</p>
<p>A map can have various flags applied to it above the statement, separated by whitespace: </p><pre class="fragment">partial alphanumeric_keys
xkb_symbols "basic" {
    ...
}
</pre><p> The possible flags are:</p>
<ul>
<li><code>partial</code> - Indicates that the map doesn't cover a complete keyboard.</li>
<li><code>default</code> - Marks the symbol map as the default map in the file when no explicit map is specified. If no map is marked as a default, the first map in the file is the default.</li>
<li><code>hidden</code> - Variant that can only be used internally</li>
<li><code>alphanumeric_keys</code> - Indicates that the map contains alphanumeric keys</li>
<li><code>modifier_keys</code> - Indicates that the map contains modifier keys</li>
<li><code>keypad_keys</code> - Indicates that the map contains keypad keys</li>
<li><code>function_keys</code> - Indicates that the map contains function keys</li>
<li><code>alternate_group</code> - Indicates that the map contains keys for an alternate group</li>
</ul>
<p>If no <code>*_keys</code> flags are supplied, then the map is assumed to cover a complete keyboard.</p>
<p>At present, except for <code>default</code>, none of the flags affect key processing in libxkbcommon, and only serve as metadata.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Name statements</h2>
<p>Statements of the form: </p><pre class="fragment">name[Group1] = "US/ASCII";
groupName[1] = "US/ASCII";
</pre><p> Gives the name "US/ASCII" to the first group of symbols. Other groups can be named using a different group index (ex: <code>Group2</code>), and with a different name. A group must be named.</p>
<p><code>group</code> and <code>groupName</code> mean the same thing, and the <code>Group</code> in <code>Group1</code> is optional.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Include statements</h2>
<p>Statements of the form: </p><pre class="fragment">include "nokia_vndr/rx-51(nordic_base)
</pre><p> Will include data from another <code>xkb_symbols</code> section, possibly located in another file. Here it would include the <code>xkb_symbols</code> section called <code>nordic_base</code>, from the file <code>rx-51</code> located in the <code>nokia_vndr</code> folder, itself located in an XKB include path.</p>
<h2><a class="anchor" id="autotoc_md46"></a>
Key statement</h2>
<p>Statements of the form: </p><pre class="fragment">key &lt;AD01&gt; { [ q, Q ] };
</pre><p> Describes the mapping of a keycode <code>&lt;AD01&gt;</code> to a given group of symbols. The possible keycodes are the keycodes defined in the <code>xkb_keycodes</code> section.</p>
<p>Symbols are named using the symbolic names from the <code>xkbcommon/xkbcommon-keysyms.h</code> file. A group of symbols is enclosed in brackets and separated by commas. Each element of the symbol arrays corresponds to a different modifier level. In this example, the symbol (keysym) <code>XKB_KEY_q</code> for level 1 and <code>XKB_KEY_Q</code> for level 2.</p>
<h3><a class="anchor" id="autotoc_md47"></a>
Groups</h3>
<p>Each group represents a list of symbols mapped to a keycode: </p><pre class="fragment">name[Group1]= "US/ASCII";
name[Group2]= "Russian";
...
key &lt;AD01&gt; { [ q, Q ],
             [ Cyrillic_shorti, Cyrillic_SHORTI ] };
</pre><p> A long-form syntax can also be used: </p><pre class="fragment">key &lt;AD01&gt; {
    symbols[Group1]= [ q, Q ],
    symbols[Group2]= [ Cyrillic_shorti, Cyrillic_SHORTI ]
};
</pre><p> Groups can also be omitted, but the brackets must be present. The following statement only defines the Group3 of a mapping: </p><pre class="fragment">key &lt;AD01&gt; { [], [], [ q, Q ] };
</pre> <h1><a class="anchor" id="autotoc_md48"></a>
Virtual modifier statements</h1>
<p>Statements of the form: </p><pre class="fragment">virtual_modifiers LControl;
</pre><p> Can appear in the <code>xkb_types</code>, <code>xkb_compat</code>, <code>xkb_symbols</code> sections.</p>
<p>TODO </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
