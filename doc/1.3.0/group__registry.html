<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libxkbcommon: Query for available RMLVO</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libxkbcommon
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Query for available RMLVO</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxkb__context.html">rxkb_context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxkb__model.html">rxkb_model</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxkb__layout.html">rxkb_layout</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxkb__option__group.html">rxkb_option_group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxkb__option.html">rxkb_option</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga53ac2cf2068770a40ce1c6faf26f8898"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga53ac2cf2068770a40ce1c6faf26f8898">rxkb_popularity</a> { <br />
&#160;&#160;<b>RXKB_POPULARITY_STANDARD</b> = 1
, <br />
&#160;&#160;<b>RXKB_POPULARITY_EXOTIC</b>
<br />
 }</td></tr>
<tr class="separator:ga53ac2cf2068770a40ce1c6faf26f8898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51409c26e106c66e71d95fa27f8c4603"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga51409c26e106c66e71d95fa27f8c4603">rxkb_context_flags</a> { <br />
&#160;&#160;<b>RXKB_CONTEXT_NO_FLAGS</b> = 0
, <br />
&#160;&#160;<a class="el" href="group__registry.html#gga51409c26e106c66e71d95fa27f8c4603a7619f7f1722f3b19770278ed0e719885">RXKB_CONTEXT_NO_DEFAULT_INCLUDES</a> = (1 &lt;&lt; 0)
, <br />
&#160;&#160;<a class="el" href="group__registry.html#gga51409c26e106c66e71d95fa27f8c4603aa5f80fee2f95543a8d4eb04058523b3a">RXKB_CONTEXT_LOAD_EXOTIC_RULES</a> = (1 &lt;&lt; 1)
<br />
 }</td></tr>
<tr class="separator:ga51409c26e106c66e71d95fa27f8c4603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c89003fff10055cd88d4be5f9668e7c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga7c89003fff10055cd88d4be5f9668e7c">rxkb_log_level</a> { <br />
&#160;&#160;<a class="el" href="group__registry.html#gga7c89003fff10055cd88d4be5f9668e7caf1ea97844e311f1b0afb24539b8bce2a">RXKB_LOG_LEVEL_CRITICAL</a> = 10
, <br />
&#160;&#160;<a class="el" href="group__registry.html#gga7c89003fff10055cd88d4be5f9668e7ca4989fec5d6da0b06a617add6c1312a24">RXKB_LOG_LEVEL_ERROR</a> = 20
, <br />
&#160;&#160;<a class="el" href="group__registry.html#gga7c89003fff10055cd88d4be5f9668e7ca471447dab8f10e2bd6584ff548cf6bba">RXKB_LOG_LEVEL_WARNING</a> = 30
, <br />
&#160;&#160;<a class="el" href="group__registry.html#gga7c89003fff10055cd88d4be5f9668e7ca14edf2f98c68f1cb51956d9479e42510">RXKB_LOG_LEVEL_INFO</a> = 40
, <br />
&#160;&#160;<a class="el" href="group__registry.html#gga7c89003fff10055cd88d4be5f9668e7cad7a89bbb9d30c1f391ef166e2cdd1cf4">RXKB_LOG_LEVEL_DEBUG</a> = 50
<br />
 }</td></tr>
<tr class="separator:ga7c89003fff10055cd88d4be5f9668e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga621dfdd7e893b15cb1c47a99e9cffa04"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga621dfdd7e893b15cb1c47a99e9cffa04">rxkb_context_new</a> (enum <a class="el" href="group__registry.html#ga51409c26e106c66e71d95fa27f8c4603">rxkb_context_flags</a> flags)</td></tr>
<tr class="separator:ga621dfdd7e893b15cb1c47a99e9cffa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacabf30755c3062429cb50eb5c9b86a9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gacabf30755c3062429cb50eb5c9b86a9f">rxkb_context_set_log_level</a> (struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx, enum <a class="el" href="group__registry.html#ga7c89003fff10055cd88d4be5f9668e7c">rxkb_log_level</a> level)</td></tr>
<tr class="separator:gacabf30755c3062429cb50eb5c9b86a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d33cc2bb884755197df2afa024327a"><td class="memItemLeft" align="right" valign="top"><a id="ga34d33cc2bb884755197df2afa024327a"></a>
enum <a class="el" href="group__registry.html#ga7c89003fff10055cd88d4be5f9668e7c">rxkb_log_level</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga34d33cc2bb884755197df2afa024327a">rxkb_context_get_log_level</a> (struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx)</td></tr>
<tr class="separator:ga34d33cc2bb884755197df2afa024327a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga370fba36925a2b548e9201ef53bd80e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga370fba36925a2b548e9201ef53bd80e5">rxkb_context_set_log_fn</a> (struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx, void(*log_fn)(struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx, enum <a class="el" href="group__registry.html#ga7c89003fff10055cd88d4be5f9668e7c">rxkb_log_level</a> level, const char *format, va_list args))</td></tr>
<tr class="separator:ga370fba36925a2b548e9201ef53bd80e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0872e56fe7502715efd37491950054d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gac0872e56fe7502715efd37491950054d">rxkb_context_parse</a> (struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx, const char *ruleset)</td></tr>
<tr class="separator:gac0872e56fe7502715efd37491950054d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac12a33490039023a15c5e71d4a5f86b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gac12a33490039023a15c5e71d4a5f86b6">rxkb_context_parse_default_ruleset</a> (struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx)</td></tr>
<tr class="separator:gac12a33490039023a15c5e71d4a5f86b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aba510969a52d5a36bd098f42bff1fc"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga8aba510969a52d5a36bd098f42bff1fc">rxkb_context_ref</a> (struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx)</td></tr>
<tr class="separator:ga8aba510969a52d5a36bd098f42bff1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f1d3b2e361345afdd6cf658ecae367"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga84f1d3b2e361345afdd6cf658ecae367">rxkb_context_unref</a> (struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx)</td></tr>
<tr class="separator:ga84f1d3b2e361345afdd6cf658ecae367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98b84ba96489a3f1c2ab41f9911ebade"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga98b84ba96489a3f1c2ab41f9911ebade">rxkb_context_set_user_data</a> (struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx, void *user_data)</td></tr>
<tr class="separator:ga98b84ba96489a3f1c2ab41f9911ebade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8736e8069bcec5437e3d00c6308d882"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gac8736e8069bcec5437e3d00c6308d882">rxkb_context_get_user_data</a> (struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx)</td></tr>
<tr class="separator:gac8736e8069bcec5437e3d00c6308d882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e71871dd8ac4180f303372ab532a4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga67e71871dd8ac4180f303372ab532a4b">rxkb_context_include_path_append</a> (struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx, const char *path)</td></tr>
<tr class="separator:ga67e71871dd8ac4180f303372ab532a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga034440b1703502b6961882974bc00030"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga034440b1703502b6961882974bc00030">rxkb_context_include_path_append_default</a> (struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx)</td></tr>
<tr class="separator:ga034440b1703502b6961882974bc00030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80021c8e4d5f1b3b0106989b336fbd19"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga80021c8e4d5f1b3b0106989b336fbd19">rxkb_model_first</a> (struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx)</td></tr>
<tr class="separator:ga80021c8e4d5f1b3b0106989b336fbd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa904641bb7376359fb11a41b72286e67"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gaa904641bb7376359fb11a41b72286e67">rxkb_model_next</a> (struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *m)</td></tr>
<tr class="separator:gaa904641bb7376359fb11a41b72286e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c9475d1e8064501fb6cb312cd5b8ea9"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga3c9475d1e8064501fb6cb312cd5b8ea9">rxkb_model_ref</a> (struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *m)</td></tr>
<tr class="separator:ga3c9475d1e8064501fb6cb312cd5b8ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac771e8aa1da739d62d050a6767023625"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gac771e8aa1da739d62d050a6767023625">rxkb_model_unref</a> (struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *m)</td></tr>
<tr class="separator:gac771e8aa1da739d62d050a6767023625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb2739e796da8f0ff509bfc88925413"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga0eb2739e796da8f0ff509bfc88925413">rxkb_model_get_name</a> (struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *m)</td></tr>
<tr class="separator:ga0eb2739e796da8f0ff509bfc88925413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6e8aa014a5601492c7e25f85b0a4ef0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gad6e8aa014a5601492c7e25f85b0a4ef0">rxkb_model_get_description</a> (struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *m)</td></tr>
<tr class="separator:gad6e8aa014a5601492c7e25f85b0a4ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2177aeb4af018f49706ffd742172497c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga2177aeb4af018f49706ffd742172497c">rxkb_model_get_vendor</a> (struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *m)</td></tr>
<tr class="separator:ga2177aeb4af018f49706ffd742172497c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bb44c06d8ed3153bc198c0121fde54a"><td class="memItemLeft" align="right" valign="top"><a id="ga3bb44c06d8ed3153bc198c0121fde54a"></a>
enum <a class="el" href="group__registry.html#ga53ac2cf2068770a40ce1c6faf26f8898">rxkb_popularity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga3bb44c06d8ed3153bc198c0121fde54a">rxkb_model_get_popularity</a> (struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *m)</td></tr>
<tr class="separator:ga3bb44c06d8ed3153bc198c0121fde54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ac08429ad8103c1301dcc2054e2edb3"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga9ac08429ad8103c1301dcc2054e2edb3">rxkb_layout_first</a> (struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx)</td></tr>
<tr class="separator:ga9ac08429ad8103c1301dcc2054e2edb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffdddb7106c882cbd4f88f03df4170b8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gaffdddb7106c882cbd4f88f03df4170b8">rxkb_layout_next</a> (struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *l)</td></tr>
<tr class="separator:gaffdddb7106c882cbd4f88f03df4170b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb3dd9122aaa364de08e8cc1d30e6a9"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga7fb3dd9122aaa364de08e8cc1d30e6a9">rxkb_layout_ref</a> (struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *l)</td></tr>
<tr class="separator:ga7fb3dd9122aaa364de08e8cc1d30e6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79357a007529e660d4145e9e90f46387"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga79357a007529e660d4145e9e90f46387">rxkb_layout_unref</a> (struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *l)</td></tr>
<tr class="separator:ga79357a007529e660d4145e9e90f46387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04de87b4cf7b56568a8dbcf0d9189327"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga04de87b4cf7b56568a8dbcf0d9189327">rxkb_layout_get_name</a> (struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *l)</td></tr>
<tr class="separator:ga04de87b4cf7b56568a8dbcf0d9189327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9311d58415bf3cb052845d4e85a3b384"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga9311d58415bf3cb052845d4e85a3b384">rxkb_layout_get_variant</a> (struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *l)</td></tr>
<tr class="separator:ga9311d58415bf3cb052845d4e85a3b384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga220e96b6cf812fff1ffaaea9f9b04cba"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga220e96b6cf812fff1ffaaea9f9b04cba">rxkb_layout_get_brief</a> (struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *l)</td></tr>
<tr class="separator:ga220e96b6cf812fff1ffaaea9f9b04cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga976ac1f644607cc24d2e2fb30dfacdf3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga976ac1f644607cc24d2e2fb30dfacdf3">rxkb_layout_get_description</a> (struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *l)</td></tr>
<tr class="separator:ga976ac1f644607cc24d2e2fb30dfacdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9958d953a7d298c80aee1bb2feda33"><td class="memItemLeft" align="right" valign="top"><a id="ga1c9958d953a7d298c80aee1bb2feda33"></a>
enum <a class="el" href="group__registry.html#ga53ac2cf2068770a40ce1c6faf26f8898">rxkb_popularity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga1c9958d953a7d298c80aee1bb2feda33">rxkb_layout_get_popularity</a> (struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *l)</td></tr>
<tr class="separator:ga1c9958d953a7d298c80aee1bb2feda33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga425d4fd081262da90d3d332277d5bcbc"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga425d4fd081262da90d3d332277d5bcbc">rxkb_option_group_first</a> (struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx)</td></tr>
<tr class="separator:ga425d4fd081262da90d3d332277d5bcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad93f6eec52660a1030a0a57f662d2845"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gad93f6eec52660a1030a0a57f662d2845">rxkb_option_group_next</a> (struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *g)</td></tr>
<tr class="separator:gad93f6eec52660a1030a0a57f662d2845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d3ef22267e2f88524f34a59c08f05c2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga9d3ef22267e2f88524f34a59c08f05c2">rxkb_option_group_ref</a> (struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *g)</td></tr>
<tr class="separator:ga9d3ef22267e2f88524f34a59c08f05c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2cc2801a5ddab11fc13fc1a63f16056"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gae2cc2801a5ddab11fc13fc1a63f16056">rxkb_option_group_unref</a> (struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *g)</td></tr>
<tr class="separator:gae2cc2801a5ddab11fc13fc1a63f16056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd82d000b8f4475b7bf905500b45e607"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gadd82d000b8f4475b7bf905500b45e607">rxkb_option_group_get_name</a> (struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *m)</td></tr>
<tr class="separator:gadd82d000b8f4475b7bf905500b45e607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6019c5fe70c0b68415ab79f9605135ad"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga6019c5fe70c0b68415ab79f9605135ad">rxkb_option_group_get_description</a> (struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *m)</td></tr>
<tr class="separator:ga6019c5fe70c0b68415ab79f9605135ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b058d09cd65bc2eefc610815c1d4a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gaa8b058d09cd65bc2eefc610815c1d4a4">rxkb_option_group_allows_multiple</a> (struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *g)</td></tr>
<tr class="separator:gaa8b058d09cd65bc2eefc610815c1d4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9f400543ef0facf8e0e12483971f01"><td class="memItemLeft" align="right" valign="top"><a id="ga3d9f400543ef0facf8e0e12483971f01"></a>
enum <a class="el" href="group__registry.html#ga53ac2cf2068770a40ce1c6faf26f8898">rxkb_popularity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga3d9f400543ef0facf8e0e12483971f01">rxkb_option_group_get_popularity</a> (struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *g)</td></tr>
<tr class="separator:ga3d9f400543ef0facf8e0e12483971f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ac8752c418c1692828f5406b1586891"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga3ac8752c418c1692828f5406b1586891">rxkb_option_first</a> (struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *group)</td></tr>
<tr class="separator:ga3ac8752c418c1692828f5406b1586891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ebbafbeebd64b1007b8a01217e82b36"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga3ebbafbeebd64b1007b8a01217e82b36">rxkb_option_next</a> (struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *o)</td></tr>
<tr class="separator:ga3ebbafbeebd64b1007b8a01217e82b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad638bc116031b4483d2a0d81d5d51fca"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gad638bc116031b4483d2a0d81d5d51fca">rxkb_option_ref</a> (struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *o)</td></tr>
<tr class="separator:gad638bc116031b4483d2a0d81d5d51fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace100ba39ece93f19df87c615f351e9b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gace100ba39ece93f19df87c615f351e9b">rxkb_option_unref</a> (struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *o)</td></tr>
<tr class="separator:gace100ba39ece93f19df87c615f351e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga956b95af834e69553c7c21fb8313ed17"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga956b95af834e69553c7c21fb8313ed17">rxkb_option_get_name</a> (struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *o)</td></tr>
<tr class="separator:ga956b95af834e69553c7c21fb8313ed17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3335384b065992bcbea1ee9f19655e93"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga3335384b065992bcbea1ee9f19655e93">rxkb_option_get_brief</a> (struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *o)</td></tr>
<tr class="separator:ga3335384b065992bcbea1ee9f19655e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90f555e22effdaee1b66c85edb829c13"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga90f555e22effdaee1b66c85edb829c13">rxkb_option_get_description</a> (struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *o)</td></tr>
<tr class="separator:ga90f555e22effdaee1b66c85edb829c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3c47eaebb2d806b556ee90b19ba6f48"><td class="memItemLeft" align="right" valign="top"><a id="gac3c47eaebb2d806b556ee90b19ba6f48"></a>
enum <a class="el" href="group__registry.html#ga53ac2cf2068770a40ce1c6faf26f8898">rxkb_popularity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gac3c47eaebb2d806b556ee90b19ba6f48">rxkb_option_get_popularity</a> (struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *o)</td></tr>
<tr class="separator:gac3c47eaebb2d806b556ee90b19ba6f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeb0a936f9d3929b2d4998038f56dd80"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gafeb0a936f9d3929b2d4998038f56dd80">rxkb_iso639_code_ref</a> (struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a> *iso639)</td></tr>
<tr class="separator:gafeb0a936f9d3929b2d4998038f56dd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fd9e59ab21f3e792d7abef72746fb3b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga6fd9e59ab21f3e792d7abef72746fb3b">rxkb_iso639_code_unref</a> (struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a> *iso639)</td></tr>
<tr class="separator:ga6fd9e59ab21f3e792d7abef72746fb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20deba24d064fe2c96179673d0e0b3e7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga20deba24d064fe2c96179673d0e0b3e7">rxkb_iso639_code_get_code</a> (struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a> *iso639)</td></tr>
<tr class="separator:ga20deba24d064fe2c96179673d0e0b3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca351835c2e0804313742075fd74ecde"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gaca351835c2e0804313742075fd74ecde">rxkb_layout_get_iso639_first</a> (struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *layout)</td></tr>
<tr class="separator:gaca351835c2e0804313742075fd74ecde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43d85cfd310d68963ecdf601c5248426"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga43d85cfd310d68963ecdf601c5248426">rxkb_iso639_code_next</a> (struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a> *iso639)</td></tr>
<tr class="separator:ga43d85cfd310d68963ecdf601c5248426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8b287fa2a7b31434977220b1fc4793"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga7f8b287fa2a7b31434977220b1fc4793">rxkb_iso3166_code_ref</a> (struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a> *iso3166)</td></tr>
<tr class="separator:ga7f8b287fa2a7b31434977220b1fc4793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d383752cb58aaec20be91299871760"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga25d383752cb58aaec20be91299871760">rxkb_iso3166_code_unref</a> (struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a> *iso3166)</td></tr>
<tr class="separator:ga25d383752cb58aaec20be91299871760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed5776d83526dddb4943226f42c8b7d1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#gaed5776d83526dddb4943226f42c8b7d1">rxkb_iso3166_code_get_code</a> (struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a> *iso3166)</td></tr>
<tr class="separator:gaed5776d83526dddb4943226f42c8b7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5217dd07b78af0a2ea4ca075c3a772e0"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga5217dd07b78af0a2ea4ca075c3a772e0">rxkb_layout_get_iso3166_first</a> (struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *layout)</td></tr>
<tr class="separator:ga5217dd07b78af0a2ea4ca075c3a772e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96ac4fb52d32f4cd33f2a3cf755c75c4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga96ac4fb52d32f4cd33f2a3cf755c75c4">rxkb_iso3166_code_next</a> (struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a> *iso3166)</td></tr>
<tr class="separator:ga96ac4fb52d32f4cd33f2a3cf755c75c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The libxkbregistry API to query for available rules, models, layouts, variants and options (RMLVO). </p>
<p>libxkbregistry is a separate library to libxkbcommon.</p>
<p>This library is the replacement for clients currently parsing evdev.xml directly. The library is intended to provide easy access to the set of <b>possible</b> MLVO configurations for a given ruleset. It is not a library to apply these configurations, merely to enumerate them. The intended users of this library are the configuration UIs that allow a user to select their keyboard layout of choice. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga53ac2cf2068770a40ce1c6faf26f8898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53ac2cf2068770a40ce1c6faf26f8898">&#9670;&nbsp;</a></span>rxkb_popularity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__registry.html#ga53ac2cf2068770a40ce1c6faf26f8898">rxkb_popularity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes the popularity of an item. </p>
<p>Historically, some highly specialized or experimental definitions are excluded from the default list and shipped in separate files. If these extra definitions are loaded (see <a class="el" href="group__registry.html#gga51409c26e106c66e71d95fa27f8c4603aa5f80fee2f95543a8d4eb04058523b3a">RXKB_CONTEXT_LOAD_EXOTIC_RULES</a>), the popularity of the item is set accordingly.</p>
<p>If the exotic items are not loaded, all items will have the standard popularity. </p>

</div>
</div>
<a id="ga51409c26e106c66e71d95fa27f8c4603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51409c26e106c66e71d95fa27f8c4603">&#9670;&nbsp;</a></span>rxkb_context_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__registry.html#ga51409c26e106c66e71d95fa27f8c4603">rxkb_context_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for context creation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga51409c26e106c66e71d95fa27f8c4603a7619f7f1722f3b19770278ed0e719885"></a>RXKB_CONTEXT_NO_DEFAULT_INCLUDES&#160;</td><td class="fielddoc"><p>Skip the default include paths. </p>
<p>This requires the caller to call <a class="el" href="group__registry.html#ga67e71871dd8ac4180f303372ab532a4b" title="Append a new entry to the context&#39;s include path.">rxkb_context_include_path_append()</a> or <a class="el" href="group__registry.html#ga034440b1703502b6961882974bc00030" title="Append the default include paths to the context&#39;s include path.">rxkb_context_include_path_append_default()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51409c26e106c66e71d95fa27f8c4603aa5f80fee2f95543a8d4eb04058523b3a"></a>RXKB_CONTEXT_LOAD_EXOTIC_RULES&#160;</td><td class="fielddoc"><p>Load the extra items that are considered too exotic for the default list. </p>
<p>For historical reasons, xkeyboard-config ships those exotic rules in a separate file (e.g. <code>evdev.extras.xml</code>). Where the exotic rules are requested, libxkbregistry will look for and load <code>$ruleset.extras.xml</code> in the include paths, see <a class="el" href="group__registry.html#ga67e71871dd8ac4180f303372ab532a4b" title="Append a new entry to the context&#39;s include path.">rxkb_context_include_path_append()</a> for details on the lookup behavior. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7c89003fff10055cd88d4be5f9668e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c89003fff10055cd88d4be5f9668e7c">&#9670;&nbsp;</a></span>rxkb_log_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__registry.html#ga7c89003fff10055cd88d4be5f9668e7c">rxkb_log_level</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a logging level. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7c89003fff10055cd88d4be5f9668e7caf1ea97844e311f1b0afb24539b8bce2a"></a>RXKB_LOG_LEVEL_CRITICAL&#160;</td><td class="fielddoc"><p>Log critical internal errors only. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7c89003fff10055cd88d4be5f9668e7ca4989fec5d6da0b06a617add6c1312a24"></a>RXKB_LOG_LEVEL_ERROR&#160;</td><td class="fielddoc"><p>Log all errors. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7c89003fff10055cd88d4be5f9668e7ca471447dab8f10e2bd6584ff548cf6bba"></a>RXKB_LOG_LEVEL_WARNING&#160;</td><td class="fielddoc"><p>Log warnings and errors. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7c89003fff10055cd88d4be5f9668e7ca14edf2f98c68f1cb51956d9479e42510"></a>RXKB_LOG_LEVEL_INFO&#160;</td><td class="fielddoc"><p>Log information, warnings, and errors. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7c89003fff10055cd88d4be5f9668e7cad7a89bbb9d30c1f391ef166e2cdd1cf4"></a>RXKB_LOG_LEVEL_DEBUG&#160;</td><td class="fielddoc"><p>Log everything. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga621dfdd7e893b15cb1c47a99e9cffa04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga621dfdd7e893b15cb1c47a99e9cffa04">&#9670;&nbsp;</a></span>rxkb_context_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__context.html">rxkb_context</a>* rxkb_context_new </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__registry.html#ga51409c26e106c66e71d95fa27f8c4603">rxkb_context_flags</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new xkb registry context. </p>
<p>The context has an initial refcount of 1. Use <a class="el" href="group__registry.html#ga84f1d3b2e361345afdd6cf658ecae367" title="Decreases the refcount of this object by one.">rxkb_context_unref()</a> to release memory associated with this context.</p>
<p>Creating a context does not parse the files yet, use <a class="el" href="group__registry.html#gac0872e56fe7502715efd37491950054d" title="Parse the given ruleset.">rxkb_context_parse()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags affecting context behavior </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new xkb registry context or NULL on failure </dd></dl>

</div>
</div>
<a id="gacabf30755c3062429cb50eb5c9b86a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacabf30755c3062429cb50eb5c9b86a9f">&#9670;&nbsp;</a></span>rxkb_context_set_log_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxkb_context_set_log_level </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__registry.html#ga7c89003fff10055cd88d4be5f9668e7c">rxkb_log_level</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current logging level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context in which to set the logging level. </td></tr>
    <tr><td class="paramname">level</td><td>The logging level to use. Only messages from this level and below will be logged.</td></tr>
  </table>
  </dd>
</dl>
<p>The default level is RXKB_LOG_LEVEL_ERROR. The environment variable RXKB_LOG_LEVEL, if set at the time the context was created, overrides the default value. It may be specified as a level number or name. </p>

</div>
</div>
<a id="ga370fba36925a2b548e9201ef53bd80e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga370fba36925a2b548e9201ef53bd80e5">&#9670;&nbsp;</a></span>rxkb_context_set_log_fn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxkb_context_set_log_fn </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *ctx, enum <a class="el" href="group__registry.html#ga7c89003fff10055cd88d4be5f9668e7c">rxkb_log_level</a> level, const char *format, va_list args)&#160;</td>
          <td class="paramname"><em>log_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a custom function to handle logging messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context in which to use the set logging function. </td></tr>
    <tr><td class="paramname">log_fn</td><td>The function that will be called for logging messages. Passing NULL restores the default function, which logs to stderr.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, log messages from this library are printed to stderr. This function allows you to replace the default behavior with a custom handler. The handler is only called with messages which match the current logging level and verbosity settings for the context. level is the logging level of the message. <em>format</em> and <em>args</em> are the same as in the vprintf(3) function.</p>
<p>You may use <a class="el" href="group__registry.html#ga98b84ba96489a3f1c2ab41f9911ebade" title="Assign user-specific data.">rxkb_context_set_user_data()</a> on the context, and then call <a class="el" href="group__registry.html#gac8736e8069bcec5437e3d00c6308d882" title="Return the pointer passed into rxkb_context_get_user_data().">rxkb_context_get_user_data()</a> from within the logging function to provide it with additional private context. </p>

</div>
</div>
<a id="gac0872e56fe7502715efd37491950054d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0872e56fe7502715efd37491950054d">&#9670;&nbsp;</a></span>rxkb_context_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rxkb_context_parse </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ruleset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the given ruleset. </p>
<p>This can only be called once per context and once parsed the data in the context is considered constant and will never change.</p>
<p>This function parses all files with the given ruleset name. See <a class="el" href="group__registry.html#ga67e71871dd8ac4180f303372ab532a4b" title="Append a new entry to the context&#39;s include path.">rxkb_context_include_path_append()</a> for details.</p>
<p>If this function returns false, libxkbregistry failed to parse the xml files. This is usually caused by invalid files on the host and should be debugged by the host's administrator using external tools. Callers should reduce the include paths to known good paths and/or fall back to a default RMLVO set.</p>
<p>If this function returns false, the context should be be considered dead and must be released with <a class="el" href="group__registry.html#ga84f1d3b2e361345afdd6cf658ecae367" title="Decreases the refcount of this object by one.">rxkb_context_unref()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The xkb registry context </td></tr>
    <tr><td class="paramname">ruleset</td><td>The ruleset to parse, e.g. "evdev" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure </dd></dl>

</div>
</div>
<a id="gac12a33490039023a15c5e71d4a5f86b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac12a33490039023a15c5e71d4a5f86b6">&#9670;&nbsp;</a></span>rxkb_context_parse_default_ruleset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rxkb_context_parse_default_ruleset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the default ruleset as configured at build time. </p>
<p>See <a class="el" href="group__registry.html#gac0872e56fe7502715efd37491950054d" title="Parse the given ruleset.">rxkb_context_parse()</a> for details. </p>

</div>
</div>
<a id="ga8aba510969a52d5a36bd098f42bff1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aba510969a52d5a36bd098f42bff1fc">&#9670;&nbsp;</a></span>rxkb_context_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__context.html">rxkb_context</a>* rxkb_context_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the refcount of this object by one and returns the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The xkb registry context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The passed in object </dd></dl>

</div>
</div>
<a id="ga84f1d3b2e361345afdd6cf658ecae367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84f1d3b2e361345afdd6cf658ecae367">&#9670;&nbsp;</a></span>rxkb_context_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__context.html">rxkb_context</a>* rxkb_context_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decreases the refcount of this object by one. </p>
<p>Where the refcount of an object hits zero, associated resources will be freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The xkb registry context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>always NULL </dd></dl>

</div>
</div>
<a id="ga98b84ba96489a3f1c2ab41f9911ebade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98b84ba96489a3f1c2ab41f9911ebade">&#9670;&nbsp;</a></span>rxkb_context_set_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxkb_context_set_user_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign user-specific data. </p>
<p>libxkbregistry will not look at or modify the data, it will merely return the same pointer in <a class="el" href="group__registry.html#gac8736e8069bcec5437e3d00c6308d882" title="Return the pointer passed into rxkb_context_get_user_data().">rxkb_context_get_user_data()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The xkb registry context </td></tr>
    <tr><td class="paramname">user_data</td><td>User-specific data pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac8736e8069bcec5437e3d00c6308d882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8736e8069bcec5437e3d00c6308d882">&#9670;&nbsp;</a></span>rxkb_context_get_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rxkb_context_get_user_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the pointer passed into <a class="el" href="group__registry.html#gac8736e8069bcec5437e3d00c6308d882" title="Return the pointer passed into rxkb_context_get_user_data().">rxkb_context_get_user_data()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The xkb registry context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>User-specific data pointer </dd></dl>

</div>
</div>
<a id="ga67e71871dd8ac4180f303372ab532a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67e71871dd8ac4180f303372ab532a4b">&#9670;&nbsp;</a></span>rxkb_context_include_path_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rxkb_context_include_path_append </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a new entry to the context's include path. </p>
<p>The include path handling is optimized for the most common use-case: a set of system files that provide a complete set of MLVO and some custom MLVO provided by a user <b>in addition</b> to the system set.</p>
<p>The include paths should be given so that the least complete path is specified first and the most complete path is appended last. For example:</p>
<div class="fragment"><div class="line">ctx = <a class="code" href="group__registry.html#ga621dfdd7e893b15cb1c47a99e9cffa04">rxkb_context_new</a>(<a class="code" href="group__registry.html#gga51409c26e106c66e71d95fa27f8c4603a7619f7f1722f3b19770278ed0e719885">RXKB_CONTEXT_NO_DEFAULT_INCLUDES</a>);</div>
<div class="line"><a class="code" href="group__registry.html#ga67e71871dd8ac4180f303372ab532a4b">rxkb_context_include_path_append</a>(ctx, <span class="stringliteral">&quot;/home/user/.config/xkb&quot;</span>);</div>
<div class="line"><a class="code" href="group__registry.html#ga67e71871dd8ac4180f303372ab532a4b">rxkb_context_include_path_append</a>(ctx, <span class="stringliteral">&quot;/usr/share/X11/xkb&quot;</span>);</div>
<div class="line"><a class="code" href="group__registry.html#gac0872e56fe7502715efd37491950054d">rxkb_context_parse</a>(ctx, <span class="stringliteral">&quot;evdev&quot;</span>);</div>
<div class="ttc" id="agroup__registry_html_ga621dfdd7e893b15cb1c47a99e9cffa04"><div class="ttname"><a href="group__registry.html#ga621dfdd7e893b15cb1c47a99e9cffa04">rxkb_context_new</a></div><div class="ttdeci">struct rxkb_context * rxkb_context_new(enum rxkb_context_flags flags)</div><div class="ttdoc">Create a new xkb registry context.</div></div>
<div class="ttc" id="agroup__registry_html_ga67e71871dd8ac4180f303372ab532a4b"><div class="ttname"><a href="group__registry.html#ga67e71871dd8ac4180f303372ab532a4b">rxkb_context_include_path_append</a></div><div class="ttdeci">bool rxkb_context_include_path_append(struct rxkb_context *ctx, const char *path)</div><div class="ttdoc">Append a new entry to the context's include path.</div></div>
<div class="ttc" id="agroup__registry_html_gac0872e56fe7502715efd37491950054d"><div class="ttname"><a href="group__registry.html#gac0872e56fe7502715efd37491950054d">rxkb_context_parse</a></div><div class="ttdeci">bool rxkb_context_parse(struct rxkb_context *ctx, const char *ruleset)</div><div class="ttdoc">Parse the given ruleset.</div></div>
<div class="ttc" id="agroup__registry_html_gga51409c26e106c66e71d95fa27f8c4603a7619f7f1722f3b19770278ed0e719885"><div class="ttname"><a href="group__registry.html#gga51409c26e106c66e71d95fa27f8c4603a7619f7f1722f3b19770278ed0e719885">RXKB_CONTEXT_NO_DEFAULT_INCLUDES</a></div><div class="ttdeci">@ RXKB_CONTEXT_NO_DEFAULT_INCLUDES</div><div class="ttdoc">Skip the default include paths.</div><div class="ttdef"><b>Definition:</b> xkbregistry.h:155</div></div>
</div><!-- fragment --><p>The above example reflects the default behavior unless <a class="el" href="group__registry.html#gga51409c26e106c66e71d95fa27f8c4603a7619f7f1722f3b19770278ed0e719885">RXKB_CONTEXT_NO_DEFAULT_INCLUDES</a> is provided.</p>
<p>Loading of the files is in <b>reverse order</b>, i.e. the last path appended is loaded first - in this case the <code>/usr/share/X11/xkb</code> path. Any models, layouts, variants and options defined in the "evdev" ruleset are loaded into the context. Then, any RMLVO found in the "evdev" ruleset of the user's path (<code>/home/user/.config/xkb</code> in this example) are <b>appended</b> to the existing set.</p>
<p>Note that data from previously loaded include paths is never overwritten, only appended to. It is not not possible to change the system-provided data, only to append new models, layouts, variants and options to it.</p>
<p>In other words, to define a new variant of the "us" layout called "banana", the following XML is sufficient.</p>
<pre class="fragment">* &lt;xkbConfigRegistry version="1.1"&gt;
* &lt;layoutList&gt;
*   &lt;layout&gt;
*     &lt;configItem&gt;
*       &lt;name&gt;us&lt;/name&gt;
*     &lt;/configItem&gt;
*     &lt;variantList&gt;
*       &lt;variant&gt;
*         &lt;configItem&gt;
*          &lt;name&gt;banana&lt;/name&gt;
*          &lt;description&gt;English (Banana)&lt;/description&gt;
*        &lt;/configItem&gt;
*      &lt;/variant&gt;
*    &lt;/layout&gt;
* &lt;/layoutList&gt;
* &lt;/xkbConfigRegistry&gt;
* </pre><p>The list of models, options and all other layouts (including "us" and its variants) is taken from the system files. The resulting list of layouts will thus have a "us" keyboard layout with the variant "banana" and all other system-provided variants (dvorak, colemak, intl, etc.)</p>
<p>This function must be called before <a class="el" href="group__registry.html#gac0872e56fe7502715efd37491950054d" title="Parse the given ruleset.">rxkb_context_parse()</a> or <a class="el" href="group__registry.html#gac12a33490039023a15c5e71d4a5f86b6" title="Parse the default ruleset as configured at build time.">rxkb_context_parse_default_ruleset()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, or false if the include path could not be added or is inaccessible. </dd></dl>

</div>
</div>
<a id="ga034440b1703502b6961882974bc00030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga034440b1703502b6961882974bc00030">&#9670;&nbsp;</a></span>rxkb_context_include_path_append_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rxkb_context_include_path_append_default </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the default include paths to the context's include path. </p>
<p>See <a class="el" href="group__registry.html#ga67e71871dd8ac4180f303372ab532a4b" title="Append a new entry to the context&#39;s include path.">rxkb_context_include_path_append()</a> for details about the merge order.</p>
<p>This function must be called before <a class="el" href="group__registry.html#gac0872e56fe7502715efd37491950054d" title="Parse the given ruleset.">rxkb_context_parse()</a> or <a class="el" href="group__registry.html#gac12a33490039023a15c5e71d4a5f86b6" title="Parse the default ruleset as configured at build time.">rxkb_context_parse_default_ruleset()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, or false if the include path could not be added or is inaccessible. </dd></dl>

</div>
</div>
<a id="ga80021c8e4d5f1b3b0106989b336fbd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80021c8e4d5f1b3b0106989b336fbd19">&#9670;&nbsp;</a></span>rxkb_model_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__model.html">rxkb_model</a>* rxkb_model_first </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first model for this context. </p>
<p>Use this to start iterating over the models, followed by calls to <a class="el" href="group__registry.html#gaa904641bb7376359fb11a41b72286e67" title="Return the next model for this context.">rxkb_model_next()</a>. Models are not sorted.</p>
<p>The refcount of the returned model is not increased. Use <a class="el" href="group__registry.html#ga3c9475d1e8064501fb6cb312cd5b8ea9" title="Increase the refcount of the argument by one.">rxkb_model_ref()</a> if you need to keep this struct outside the immediate scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The first model in the model list. </dd></dl>

</div>
</div>
<a id="gaa904641bb7376359fb11a41b72286e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa904641bb7376359fb11a41b72286e67">&#9670;&nbsp;</a></span>rxkb_model_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__model.html">rxkb_model</a>* rxkb_model_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next model for this context. </p>
<p>Returns NULL when no more models are available.</p>
<p>The refcount of the returned model is not increased. Use <a class="el" href="group__registry.html#ga3c9475d1e8064501fb6cb312cd5b8ea9" title="Increase the refcount of the argument by one.">rxkb_model_ref()</a> if you need to keep this struct outside the immediate scope.</p>
<dl class="section return"><dt>Returns</dt><dd>the next model or NULL at the end of the list </dd></dl>

</div>
</div>
<a id="ga3c9475d1e8064501fb6cb312cd5b8ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c9475d1e8064501fb6cb312cd5b8ea9">&#9670;&nbsp;</a></span>rxkb_model_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__model.html">rxkb_model</a>* rxkb_model_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the refcount of the argument by one. </p>
<dl class="section return"><dt>Returns</dt><dd>The argument passed in to this function. </dd></dl>

</div>
</div>
<a id="gac771e8aa1da739d62d050a6767023625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac771e8aa1da739d62d050a6767023625">&#9670;&nbsp;</a></span>rxkb_model_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__model.html">rxkb_model</a>* rxkb_model_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the refcount of the argument by one. </p>
<p>When the refcount hits zero, all memory associated with this struct is freed.</p>
<dl class="section return"><dt>Returns</dt><dd>always NULL </dd></dl>

</div>
</div>
<a id="ga0eb2739e796da8f0ff509bfc88925413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eb2739e796da8f0ff509bfc88925413">&#9670;&nbsp;</a></span>rxkb_model_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rxkb_model_get_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of this model. </p>
<p>This is the value for M in RMLVO, to be used with libxkbcommon. </p>

</div>
</div>
<a id="gad6e8aa014a5601492c7e25f85b0a4ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6e8aa014a5601492c7e25f85b0a4ef0">&#9670;&nbsp;</a></span>rxkb_model_get_description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rxkb_model_get_description </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a human-readable description of this model. </p>
<p>This function may return NULL. </p>

</div>
</div>
<a id="ga2177aeb4af018f49706ffd742172497c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2177aeb4af018f49706ffd742172497c">&#9670;&nbsp;</a></span>rxkb_model_get_vendor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rxkb_model_get_vendor </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__model.html">rxkb_model</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vendor name for this model. </p>
<p>This function may return NULL. </p>

</div>
</div>
<a id="ga9ac08429ad8103c1301dcc2054e2edb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ac08429ad8103c1301dcc2054e2edb3">&#9670;&nbsp;</a></span>rxkb_layout_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a>* rxkb_layout_first </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first layout for this context. </p>
<p>Use this to start iterating over the layouts, followed by calls to <a class="el" href="group__registry.html#gaffdddb7106c882cbd4f88f03df4170b8" title="Return the next layout for this context.">rxkb_layout_next()</a>. Layouts are not sorted.</p>
<p>The refcount of the returned layout is not increased. Use <a class="el" href="group__registry.html#ga7fb3dd9122aaa364de08e8cc1d30e6a9" title="Increase the refcount of the argument by one.">rxkb_layout_ref()</a> if you need to keep this struct outside the immediate scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The first layout in the layout list. </dd></dl>

</div>
</div>
<a id="gaffdddb7106c882cbd4f88f03df4170b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffdddb7106c882cbd4f88f03df4170b8">&#9670;&nbsp;</a></span>rxkb_layout_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a>* rxkb_layout_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next layout for this context. </p>
<p>Returns NULL when no more layouts are available.</p>
<p>The refcount of the returned layout is not increased. Use <a class="el" href="group__registry.html#ga7fb3dd9122aaa364de08e8cc1d30e6a9" title="Increase the refcount of the argument by one.">rxkb_layout_ref()</a> if you need to keep this struct outside the immediate scope.</p>
<dl class="section return"><dt>Returns</dt><dd>the next layout or NULL at the end of the list </dd></dl>

</div>
</div>
<a id="ga7fb3dd9122aaa364de08e8cc1d30e6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fb3dd9122aaa364de08e8cc1d30e6a9">&#9670;&nbsp;</a></span>rxkb_layout_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a>* rxkb_layout_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the refcount of the argument by one. </p>
<dl class="section return"><dt>Returns</dt><dd>The argument passed in to this function. </dd></dl>

</div>
</div>
<a id="ga79357a007529e660d4145e9e90f46387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79357a007529e660d4145e9e90f46387">&#9670;&nbsp;</a></span>rxkb_layout_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a>* rxkb_layout_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the refcount of the argument by one. </p>
<p>When the refcount hits zero, all memory associated with this struct is freed.</p>
<dl class="section return"><dt>Returns</dt><dd>always NULL </dd></dl>

</div>
</div>
<a id="ga04de87b4cf7b56568a8dbcf0d9189327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04de87b4cf7b56568a8dbcf0d9189327">&#9670;&nbsp;</a></span>rxkb_layout_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rxkb_layout_get_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of this layout. </p>
<p>This is the value for L in RMLVO, to be used with libxkbcommon. </p>

</div>
</div>
<a id="ga9311d58415bf3cb052845d4e85a3b384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9311d58415bf3cb052845d4e85a3b384">&#9670;&nbsp;</a></span>rxkb_layout_get_variant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rxkb_layout_get_variant </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the variant of this layout. </p>
<p>This is the value for V in RMLVO, to be used with libxkbcommon.</p>
<p>A variant does not stand on its own, it always depends on the base layout. e.g. there may be multiple variants called "intl" but there is only one "us(intl)".</p>
<p>Where the variant is NULL, the layout is the base layout (e.g. "us"). </p>

</div>
</div>
<a id="ga220e96b6cf812fff1ffaaea9f9b04cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga220e96b6cf812fff1ffaaea9f9b04cba">&#9670;&nbsp;</a></span>rxkb_layout_get_brief()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rxkb_layout_get_brief </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a short (one-word) description of this layout. </p>
<p>This function may return NULL. </p>

</div>
</div>
<a id="ga976ac1f644607cc24d2e2fb30dfacdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga976ac1f644607cc24d2e2fb30dfacdf3">&#9670;&nbsp;</a></span>rxkb_layout_get_description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rxkb_layout_get_description </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a human-readable description of this layout. </p>
<p>This function may return NULL. </p>

</div>
</div>
<a id="ga425d4fd081262da90d3d332277d5bcbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga425d4fd081262da90d3d332277d5bcbc">&#9670;&nbsp;</a></span>rxkb_option_group_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a>* rxkb_option_group_first </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__context.html">rxkb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first option group for this context. </p>
<p>Use this to start iterating over the option groups, followed by calls to <a class="el" href="group__registry.html#gad93f6eec52660a1030a0a57f662d2845" title="Return the next option group for this context.">rxkb_option_group_next()</a>. Option groups are not sorted.</p>
<p>The refcount of the returned option group is not increased. Use <a class="el" href="group__registry.html#ga9d3ef22267e2f88524f34a59c08f05c2" title="Increase the refcount of the argument by one.">rxkb_option_group_ref()</a> if you need to keep this struct outside the immediate scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The first option group in the option group list. </dd></dl>

</div>
</div>
<a id="gad93f6eec52660a1030a0a57f662d2845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad93f6eec52660a1030a0a57f662d2845">&#9670;&nbsp;</a></span>rxkb_option_group_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a>* rxkb_option_group_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next option group for this context. </p>
<p>Returns NULL when no more option groups are available.</p>
<p>The refcount of the returned option group is not increased. Use <a class="el" href="group__registry.html#ga9d3ef22267e2f88524f34a59c08f05c2" title="Increase the refcount of the argument by one.">rxkb_option_group_ref()</a> if you need to keep this struct outside the immediate scope.</p>
<dl class="section return"><dt>Returns</dt><dd>the next option group or NULL at the end of the list </dd></dl>

</div>
</div>
<a id="ga9d3ef22267e2f88524f34a59c08f05c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d3ef22267e2f88524f34a59c08f05c2">&#9670;&nbsp;</a></span>rxkb_option_group_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a>* rxkb_option_group_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the refcount of the argument by one. </p>
<dl class="section return"><dt>Returns</dt><dd>The argument passed in to this function. </dd></dl>

</div>
</div>
<a id="gae2cc2801a5ddab11fc13fc1a63f16056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2cc2801a5ddab11fc13fc1a63f16056">&#9670;&nbsp;</a></span>rxkb_option_group_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a>* rxkb_option_group_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the refcount of the argument by one. </p>
<p>When the refcount hits zero, all memory associated with this struct is freed.</p>
<dl class="section return"><dt>Returns</dt><dd>always NULL </dd></dl>

</div>
</div>
<a id="gadd82d000b8f4475b7bf905500b45e607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd82d000b8f4475b7bf905500b45e607">&#9670;&nbsp;</a></span>rxkb_option_group_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rxkb_option_group_get_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of this option group. </p>
<p>This is <b>not</b> the value for O in RMLVO, the name can be used for internal sorting in the caller. This function may return NULL. </p>

</div>
</div>
<a id="ga6019c5fe70c0b68415ab79f9605135ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6019c5fe70c0b68415ab79f9605135ad">&#9670;&nbsp;</a></span>rxkb_option_group_get_description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rxkb_option_group_get_description </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a human-readable description of this option group. </p>
<p>This function may return NULL. </p>

</div>
</div>
<a id="gaa8b058d09cd65bc2eefc610815c1d4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8b058d09cd65bc2eefc610815c1d4a4">&#9670;&nbsp;</a></span>rxkb_option_group_allows_multiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rxkb_option_group_allows_multiple </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if multiple options within this option group can be selected simultaneously, false if all options within this option group are mutually exclusive. </dd></dl>

</div>
</div>
<a id="ga3ac8752c418c1692828f5406b1586891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ac8752c418c1692828f5406b1586891">&#9670;&nbsp;</a></span>rxkb_option_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__option.html">rxkb_option</a>* rxkb_option_first </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__option__group.html">rxkb_option_group</a> *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first option for this option group. </p>
<p>Use this to start iterating over the options, followed by calls to <a class="el" href="group__registry.html#ga3ebbafbeebd64b1007b8a01217e82b36" title="Return the next option for this option group.">rxkb_option_next()</a>. Options are not sorted.</p>
<p>The refcount of the returned option is not increased. Use <a class="el" href="group__registry.html#gad638bc116031b4483d2a0d81d5d51fca" title="Increase the refcount of the argument by one.">rxkb_option_ref()</a> if you need to keep this struct outside the immediate scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The first option in the option list. </dd></dl>

</div>
</div>
<a id="ga3ebbafbeebd64b1007b8a01217e82b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ebbafbeebd64b1007b8a01217e82b36">&#9670;&nbsp;</a></span>rxkb_option_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__option.html">rxkb_option</a>* rxkb_option_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next option for this option group. </p>
<p>Returns NULL when no more options are available.</p>
<p>The refcount of the returned options is not increased. Use <a class="el" href="group__registry.html#gad638bc116031b4483d2a0d81d5d51fca" title="Increase the refcount of the argument by one.">rxkb_option_ref()</a> if you need to keep this struct outside the immediate scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The next option or NULL at the end of the list </dd></dl>

</div>
</div>
<a id="gad638bc116031b4483d2a0d81d5d51fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad638bc116031b4483d2a0d81d5d51fca">&#9670;&nbsp;</a></span>rxkb_option_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__option.html">rxkb_option</a>* rxkb_option_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the refcount of the argument by one. </p>
<dl class="section return"><dt>Returns</dt><dd>The argument passed in to this function. </dd></dl>

</div>
</div>
<a id="gace100ba39ece93f19df87c615f351e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace100ba39ece93f19df87c615f351e9b">&#9670;&nbsp;</a></span>rxkb_option_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__option.html">rxkb_option</a>* rxkb_option_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the refcount of the argument by one. </p>
<p>When the refcount hits zero, all memory associated with this struct is freed.</p>
<dl class="section return"><dt>Returns</dt><dd>always NULL </dd></dl>

</div>
</div>
<a id="ga956b95af834e69553c7c21fb8313ed17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga956b95af834e69553c7c21fb8313ed17">&#9670;&nbsp;</a></span>rxkb_option_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rxkb_option_get_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of this option. </p>
<p>This is the value for O in RMLVO, to be used with libxkbcommon. </p>

</div>
</div>
<a id="ga3335384b065992bcbea1ee9f19655e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3335384b065992bcbea1ee9f19655e93">&#9670;&nbsp;</a></span>rxkb_option_get_brief()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rxkb_option_get_brief </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a short (one-word) description of this option. </p>
<p>This function may return NULL. </p>

</div>
</div>
<a id="ga90f555e22effdaee1b66c85edb829c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90f555e22effdaee1b66c85edb829c13">&#9670;&nbsp;</a></span>rxkb_option_get_description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rxkb_option_get_description </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__option.html">rxkb_option</a> *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a human-readable description of this option. </p>
<p>This function may return NULL. </p>

</div>
</div>
<a id="gafeb0a936f9d3929b2d4998038f56dd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafeb0a936f9d3929b2d4998038f56dd80">&#9670;&nbsp;</a></span>rxkb_iso639_code_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a>* rxkb_iso639_code_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a> *&#160;</td>
          <td class="paramname"><em>iso639</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the refcount of the argument by one. </p>
<dl class="section return"><dt>Returns</dt><dd>The argument passed in to this function. </dd></dl>

</div>
</div>
<a id="ga6fd9e59ab21f3e792d7abef72746fb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fd9e59ab21f3e792d7abef72746fb3b">&#9670;&nbsp;</a></span>rxkb_iso639_code_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a>* rxkb_iso639_code_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a> *&#160;</td>
          <td class="paramname"><em>iso639</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the refcount of the argument by one. </p>
<p>When the refcount hits zero, all memory associated with this struct is freed.</p>
<dl class="section return"><dt>Returns</dt><dd>always NULL </dd></dl>

</div>
</div>
<a id="ga20deba24d064fe2c96179673d0e0b3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20deba24d064fe2c96179673d0e0b3e7">&#9670;&nbsp;</a></span>rxkb_iso639_code_get_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rxkb_iso639_code_get_code </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a> *&#160;</td>
          <td class="paramname"><em>iso639</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the ISO 639-3 code for this code (e.g. </p>
<p>"eng", "fra"). </p>

</div>
</div>
<a id="gaca351835c2e0804313742075fd74ecde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca351835c2e0804313742075fd74ecde">&#9670;&nbsp;</a></span>rxkb_layout_get_iso639_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a>* rxkb_layout_get_iso639_first </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first ISO 639 for this layout. </p>
<p>Use this to start iterating over the codes, followed by calls to <a class="el" href="group__registry.html#ga43d85cfd310d68963ecdf601c5248426" title="Return the next code in the list.">rxkb_iso639_code_next()</a>. Codes are not sorted.</p>
<p>The refcount of the returned code is not increased. Use <a class="el" href="group__registry.html#gafeb0a936f9d3929b2d4998038f56dd80" title="Increase the refcount of the argument by one.">rxkb_iso639_code_ref()</a> if you need to keep this struct outside the immediate scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The first code in the code list. </dd></dl>

</div>
</div>
<a id="ga43d85cfd310d68963ecdf601c5248426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43d85cfd310d68963ecdf601c5248426">&#9670;&nbsp;</a></span>rxkb_iso639_code_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a>* rxkb_iso639_code_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__iso639__code.html">rxkb_iso639_code</a> *&#160;</td>
          <td class="paramname"><em>iso639</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next code in the list. </p>
<p>Returns NULL when no more codes are available.</p>
<p>The refcount of the returned codes is not increased. Use <a class="el" href="group__registry.html#gafeb0a936f9d3929b2d4998038f56dd80" title="Increase the refcount of the argument by one.">rxkb_iso639_code_ref()</a> if you need to keep this struct outside the immediate scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The next code or NULL at the end of the list </dd></dl>

</div>
</div>
<a id="ga7f8b287fa2a7b31434977220b1fc4793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f8b287fa2a7b31434977220b1fc4793">&#9670;&nbsp;</a></span>rxkb_iso3166_code_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a>* rxkb_iso3166_code_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a> *&#160;</td>
          <td class="paramname"><em>iso3166</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the refcount of the argument by one. </p>
<dl class="section return"><dt>Returns</dt><dd>The argument passed in to this function. </dd></dl>

</div>
</div>
<a id="ga25d383752cb58aaec20be91299871760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25d383752cb58aaec20be91299871760">&#9670;&nbsp;</a></span>rxkb_iso3166_code_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a>* rxkb_iso3166_code_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a> *&#160;</td>
          <td class="paramname"><em>iso3166</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the refcount of the argument by one. </p>
<p>When the refcount hits zero, all memory associated with this struct is freed.</p>
<dl class="section return"><dt>Returns</dt><dd>always NULL </dd></dl>

</div>
</div>
<a id="gaed5776d83526dddb4943226f42c8b7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed5776d83526dddb4943226f42c8b7d1">&#9670;&nbsp;</a></span>rxkb_iso3166_code_get_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rxkb_iso3166_code_get_code </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a> *&#160;</td>
          <td class="paramname"><em>iso3166</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the ISO 3166 Alpha 2 code for this code (e.g. </p>
<p>"US", "FR"). </p>

</div>
</div>
<a id="ga5217dd07b78af0a2ea4ca075c3a772e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5217dd07b78af0a2ea4ca075c3a772e0">&#9670;&nbsp;</a></span>rxkb_layout_get_iso3166_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a>* rxkb_layout_get_iso3166_first </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__layout.html">rxkb_layout</a> *&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first ISO 3166 for this layout. </p>
<p>Use this to start iterating over the codes, followed by calls to <a class="el" href="group__registry.html#ga96ac4fb52d32f4cd33f2a3cf755c75c4" title="Return the next code in the list.">rxkb_iso3166_code_next()</a>. Codes are not sorted.</p>
<p>The refcount of the returned code is not increased. Use <a class="el" href="group__registry.html#ga7f8b287fa2a7b31434977220b1fc4793" title="Increase the refcount of the argument by one.">rxkb_iso3166_code_ref()</a> if you need to keep this struct outside the immediate scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The first code in the code list. </dd></dl>

</div>
</div>
<a id="ga96ac4fb52d32f4cd33f2a3cf755c75c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96ac4fb52d32f4cd33f2a3cf755c75c4">&#9670;&nbsp;</a></span>rxkb_iso3166_code_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a>* rxkb_iso3166_code_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxkb__iso3166__code.html">rxkb_iso3166_code</a> *&#160;</td>
          <td class="paramname"><em>iso3166</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next code in the list. </p>
<p>Returns NULL when no more codes are available.</p>
<p>The refcount of the returned codes is not increased. Use <a class="el" href="group__registry.html#ga7f8b287fa2a7b31434977220b1fc4793" title="Increase the refcount of the argument by one.">rxkb_iso3166_code_ref()</a> if you need to keep this struct outside the immediate scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The next code or NULL at the end of the list </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
