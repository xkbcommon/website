<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libxkbcommon: Quick Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libxkbcommon<span id="projectnumber">&#160;1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Quick Guide </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md9"></a>
Introduction</h1>
<p >This document contains a quick walk-through of the often-used parts of the library. We will employ a few use-cases to lead the examples:</p>
<ol type="1">
<li>An evdev client. "evdev" is the Linux kernel's input subsystem; it only reports to the client which keys are pressed and released.</li>
<li>An X11 client, using the XCB library to communicate with the X server and the xcb-xkb library for using the XKB protocol.</li>
<li>A Wayland client, using the standard protocol.</li>
</ol>
<p >The snippets are not complete, and some support code is omitted. You can find complete and more complex examples in the source directory:</p>
<ol type="1">
<li>tools/interactive-evdev.c contains an interactive evdev client.</li>
<li>tools/interactive-x11.c contains an interactive X11 client.</li>
<li>tools/interactive-wayland.c contains an interactive Wayland client.</li>
</ol>
<p >Also, the library contains many more functions for examining and using the library context, the keymap and the keyboard state. See the hyper-linked reference documentation or go through the header files in xkbcommon/ for more details.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Code</h1>
<p >Before we can do anything interesting, we need a library context:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="xkbcommon_8h.html">xkbcommon/xkbcommon.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structxkb__context.html">xkb_context</a> *ctx;</div>
<div class="line"> </div>
<div class="line">ctx = <a class="code hl_function" href="group__context.html#gacecddbdb020205f335719fe445dc9fdc">xkb_context_new</a>(<a class="code hl_enumvalue" href="group__context.html#ggaea2acb5b9e06239e20a7c34f5b223092a52382673b85690e1990796b1c9c20538">XKB_CONTEXT_NO_FLAGS</a>);</div>
<div class="line"><span class="keywordflow">if</span> (!ctx) &lt;error&gt;</div>
<div class="ttc" id="agroup__context_html_gacecddbdb020205f335719fe445dc9fdc"><div class="ttname"><a href="group__context.html#gacecddbdb020205f335719fe445dc9fdc">xkb_context::xkb_context_new</a></div><div class="ttdeci">struct xkb_context * xkb_context_new(enum xkb_context_flags flags)</div><div class="ttdoc">Create a new context.</div></div>
<div class="ttc" id="agroup__context_html_ggaea2acb5b9e06239e20a7c34f5b223092a52382673b85690e1990796b1c9c20538"><div class="ttname"><a href="group__context.html#ggaea2acb5b9e06239e20a7c34f5b223092a52382673b85690e1990796b1c9c20538">XKB_CONTEXT_NO_FLAGS</a></div><div class="ttdeci">@ XKB_CONTEXT_NO_FLAGS</div><div class="ttdoc">Do not apply any context flags.</div><div class="ttdef"><b>Definition:</b> xkbcommon.h:578</div></div>
<div class="ttc" id="astructxkb__context_html"><div class="ttname"><a href="structxkb__context.html">xkb_context</a></div><div class="ttdoc">Opaque top level library context object.</div></div>
<div class="ttc" id="axkbcommon_8h_html"><div class="ttname"><a href="xkbcommon_8h.html">xkbcommon.h</a></div><div class="ttdoc">Main libxkbcommon API.</div></div>
</div><!-- fragment --><p >The <code><a class="el" href="structxkb__context.html" title="Opaque top level library context object.">xkb_context</a></code> contains the keymap include paths, the log level and functions, and other general customizable administrativia.</p>
<p >Next we need to create a keymap, <code><a class="el" href="structxkb__keymap.html" title="Opaque compiled keymap object.">xkb_keymap</a></code>. This is an immutable object which contains all of the information about the keys, layouts, etc. There are different ways to do this.</p>
<p >If we are an evdev client, we have nothing to go by, so we need to ask the user for his/her keymap preferences (for example, an Icelandic keyboard with a Dvorak layout). The configuration format is commonly called RMLVO (Rules+Model+Layout+Variant+Options), the same format used by the X server. With it, we can fill a struct called <code><a class="el" href="structxkb__rule__names.html" title="Names to compile a keymap with, also known as RMLVO.">xkb_rule_names</a></code>; passing <code>NULL</code> chooses the system's default.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structxkb__keymap.html">xkb_keymap</a> *keymap;</div>
<div class="line"><span class="comment">/* Example RMLVO for Icelandic Dvorak. */</span></div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structxkb__rule__names.html">xkb_rule_names</a> names = {</div>
<div class="line">    .<a class="code hl_variable" href="structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280">rules</a> = NULL,</div>
<div class="line">    .model = <span class="stringliteral">&quot;pc105&quot;</span>,</div>
<div class="line">    .layout = <span class="stringliteral">&quot;is&quot;</span>,</div>
<div class="line">    .variant = <span class="stringliteral">&quot;dvorak&quot;</span>,</div>
<div class="line">    .options = <span class="stringliteral">&quot;terminate:ctrl_alt_bksp&quot;</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">keymap = <a class="code hl_function" href="group__keymap.html#ga502717aa7148fd17d4970896f1e9e06f">xkb_keymap_new_from_names</a>(ctx, &amp;names,</div>
<div class="line">                                   <a class="code hl_enumvalue" href="group__keymap.html#ggad418fa5861e00b37c362075a380299b2ae274bf0a09997d395e712156b0dbf7fa">XKB_KEYMAP_COMPILE_NO_FLAGS</a>);</div>
<div class="line"><span class="keywordflow">if</span> (!keymap) &lt;error&gt;</div>
<div class="ttc" id="agroup__keymap_html_ga502717aa7148fd17d4970896f1e9e06f"><div class="ttname"><a href="group__keymap.html#ga502717aa7148fd17d4970896f1e9e06f">xkb_keymap::xkb_keymap_new_from_names</a></div><div class="ttdeci">struct xkb_keymap * xkb_keymap_new_from_names(struct xkb_context *context, const struct xkb_rule_names *names, enum xkb_keymap_compile_flags flags)</div><div class="ttdoc">Create a keymap from RMLVO names.</div></div>
<div class="ttc" id="agroup__keymap_html_ggad418fa5861e00b37c362075a380299b2ae274bf0a09997d395e712156b0dbf7fa"><div class="ttname"><a href="group__keymap.html#ggad418fa5861e00b37c362075a380299b2ae274bf0a09997d395e712156b0dbf7fa">XKB_KEYMAP_COMPILE_NO_FLAGS</a></div><div class="ttdeci">@ XKB_KEYMAP_COMPILE_NO_FLAGS</div><div class="ttdoc">Do not apply any flags.</div><div class="ttdef"><b>Definition:</b> xkbcommon.h:840</div></div>
<div class="ttc" id="astructxkb__keymap_html"><div class="ttname"><a href="structxkb__keymap.html">xkb_keymap</a></div><div class="ttdoc">Opaque compiled keymap object.</div><div class="ttdef"><b>Definition:</b> xkbcommon.h:111</div></div>
<div class="ttc" id="astructxkb__rule__names_html"><div class="ttname"><a href="structxkb__rule__names.html">xkb_rule_names</a></div><div class="ttdoc">Names to compile a keymap with, also known as RMLVO.</div><div class="ttdef"><b>Definition:</b> xkbcommon.h:327</div></div>
<div class="ttc" id="astructxkb__rule__names_html_a0968f4602001f2306febd32c34bd2280"><div class="ttname"><a href="structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280">xkb_rule_names::rules</a></div><div class="ttdeci">const char * rules</div><div class="ttdoc">The rules file to use.</div><div class="ttdef"><b>Definition:</b> xkbcommon.h:336</div></div>
</div><!-- fragment --><p >If we are a Wayland client, the compositor gives us a string complete with a keymap. In this case, we can create the keymap object like this:</p>
<div class="fragment"><div class="line"><span class="comment">/* From the wl_keyboard::keymap event. */</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *keymap_string = &lt;...&gt;;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structxkb__keymap.html">xkb_keymap</a> *keymap;</div>
<div class="line"> </div>
<div class="line">keymap = <a class="code hl_function" href="group__keymap.html#ga9d98e2e1348bd756bd3229d0b9432886">xkb_keymap_new_from_string</a>(ctx, keymap_string,</div>
<div class="line">                                    <a class="code hl_enumvalue" href="group__keymap.html#ggab0f75d6cc5773e5dd404e2c3f61366a3ad63ee709a87611a89b42c3e1275347ed">XKB_KEYMAP_FORMAT_TEXT_V1</a>,</div>
<div class="line">                                    <a class="code hl_enumvalue" href="group__keymap.html#ggad418fa5861e00b37c362075a380299b2ae274bf0a09997d395e712156b0dbf7fa">XKB_KEYMAP_COMPILE_NO_FLAGS</a>);</div>
<div class="line"><span class="keywordflow">if</span> (!keymap) &lt;error&gt;</div>
<div class="ttc" id="agroup__keymap_html_ga9d98e2e1348bd756bd3229d0b9432886"><div class="ttname"><a href="group__keymap.html#ga9d98e2e1348bd756bd3229d0b9432886">xkb_keymap::xkb_keymap_new_from_string</a></div><div class="ttdeci">struct xkb_keymap * xkb_keymap_new_from_string(struct xkb_context *context, const char *string, enum xkb_keymap_format format, enum xkb_keymap_compile_flags flags)</div><div class="ttdoc">Create a keymap from a keymap string.</div></div>
<div class="ttc" id="agroup__keymap_html_ggab0f75d6cc5773e5dd404e2c3f61366a3ad63ee709a87611a89b42c3e1275347ed"><div class="ttname"><a href="group__keymap.html#ggab0f75d6cc5773e5dd404e2c3f61366a3ad63ee709a87611a89b42c3e1275347ed">XKB_KEYMAP_FORMAT_TEXT_V1</a></div><div class="ttdeci">@ XKB_KEYMAP_FORMAT_TEXT_V1</div><div class="ttdoc">The current/classic XKB text format, as generated by xkbcomp -xkb.</div><div class="ttdef"><b>Definition:</b> xkbcommon.h:867</div></div>
</div><!-- fragment --><p >If we are an X11 client, we are better off getting the keymap from the X server directly. For this we need to choose the XInput device; here we will use the core keyboard device:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="xkbcommon-x11_8h.html">xkbcommon/xkbcommon-x11.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">xcb_connection_t *conn = &lt;...&gt;;</div>
<div class="line">int32_t device_id;</div>
<div class="line"> </div>
<div class="line">device_id = <a class="code hl_function" href="group__x11.html#ga8b01ff183ac596884b008e1c65f1afea">xkb_x11_get_core_keyboard_device_id</a>(conn);</div>
<div class="line"><span class="keywordflow">if</span> (device_id == -1) &lt;error&gt;</div>
<div class="line"> </div>
<div class="line">keymap = <a class="code hl_function" href="group__x11.html#ga9ccc80dcb7488167c8466cb833286559">xkb_x11_keymap_new_from_device</a>(ctx, conn, device_id,</div>
<div class="line">                                        <a class="code hl_enumvalue" href="group__keymap.html#ggad418fa5861e00b37c362075a380299b2ae274bf0a09997d395e712156b0dbf7fa">XKB_KEYMAP_COMPILE_NO_FLAGS</a>);</div>
<div class="line"><span class="keywordflow">if</span> (!keymap) &lt;error&gt;</div>
<div class="ttc" id="agroup__x11_html_ga8b01ff183ac596884b008e1c65f1afea"><div class="ttname"><a href="group__x11.html#ga8b01ff183ac596884b008e1c65f1afea">xkb_x11_get_core_keyboard_device_id</a></div><div class="ttdeci">int32_t xkb_x11_get_core_keyboard_device_id(xcb_connection_t *connection)</div><div class="ttdoc">Get the keyboard device ID of the core X11 keyboard.</div></div>
<div class="ttc" id="agroup__x11_html_ga9ccc80dcb7488167c8466cb833286559"><div class="ttname"><a href="group__x11.html#ga9ccc80dcb7488167c8466cb833286559">xkb_keymap::xkb_x11_keymap_new_from_device</a></div><div class="ttdeci">struct xkb_keymap * xkb_x11_keymap_new_from_device(struct xkb_context *context, xcb_connection_t *connection, int32_t device_id, enum xkb_keymap_compile_flags flags)</div><div class="ttdoc">Create a keymap from an X11 keyboard device.</div></div>
<div class="ttc" id="axkbcommon-x11_8h_html"><div class="ttname"><a href="xkbcommon-x11_8h.html">xkbcommon-x11.h</a></div><div class="ttdoc">libxkbcommon-x11 API - Additional X11 support for xkbcommon.</div></div>
</div><!-- fragment --><p >Now that we have the keymap, we are ready to handle the keyboard devices. For each device, we create an <code><a class="el" href="structxkb__state.html" title="Opaque keyboard state object.">xkb_state</a></code>, which remembers things like which keyboard modifiers and LEDs are active:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structxkb__state.html">xkb_state</a> *state;</div>
<div class="line"> </div>
<div class="line">state = <a class="code hl_function" href="group__state.html#ga281f0dc1cab624ab11e7c4d318d9d4ac">xkb_state_new</a>(keymap);</div>
<div class="line"><span class="keywordflow">if</span> (!state) &lt;error&gt;</div>
<div class="ttc" id="agroup__state_html_ga281f0dc1cab624ab11e7c4d318d9d4ac"><div class="ttname"><a href="group__state.html#ga281f0dc1cab624ab11e7c4d318d9d4ac">xkb_state::xkb_state_new</a></div><div class="ttdeci">struct xkb_state * xkb_state_new(struct xkb_keymap *keymap)</div><div class="ttdoc">Create a new keyboard state object.</div></div>
<div class="ttc" id="astructxkb__state_html"><div class="ttname"><a href="structxkb__state.html">xkb_state</a></div><div class="ttdoc">Opaque keyboard state object.</div><div class="ttdef"><b>Definition:</b> xkbcommon.h:123</div></div>
</div><!-- fragment --><p >For X11/XCB clients, this is better:</p>
<div class="fragment"><div class="line">state = <a class="code hl_function" href="group__x11.html#gaf710c637c60d9a47a9cce37b89d2afe2">xkb_x11_state_new_from_device</a>(keymap, conn, device_id);</div>
<div class="line"><span class="keywordflow">if</span> (!state) &lt;error&gt;</div>
<div class="ttc" id="agroup__x11_html_gaf710c637c60d9a47a9cce37b89d2afe2"><div class="ttname"><a href="group__x11.html#gaf710c637c60d9a47a9cce37b89d2afe2">xkb_state::xkb_x11_state_new_from_device</a></div><div class="ttdeci">struct xkb_state * xkb_x11_state_new_from_device(struct xkb_keymap *keymap, xcb_connection_t *connection, int32_t device_id)</div><div class="ttdoc">Create a new keyboard state object from an X11 keyboard device.</div></div>
</div><!-- fragment --><p >When we have an <code><a class="el" href="structxkb__state.html" title="Opaque keyboard state object.">xkb_state</a></code> for a device, we can start handling key events from it. Given a keycode for a key, we can get its keysym:</p>
<div class="fragment"><div class="line">&lt;key <span class="keyword">event</span> structure&gt; event;</div>
<div class="line"><a class="code hl_typedef" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> keycode;</div>
<div class="line"><a class="code hl_typedef" href="xkbcommon_8h.html#a79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a> keysym;</div>
<div class="line"> </div>
<div class="line">keycode = <span class="keyword">event</span>-&gt;keycode;</div>
<div class="line">keysym = <a class="code hl_function" href="group__state.html#gae56031a8c1d48e7802da32f5f39f5738">xkb_state_key_get_one_sym</a>(state, keycode);</div>
<div class="ttc" id="agroup__state_html_gae56031a8c1d48e7802da32f5f39f5738"><div class="ttname"><a href="group__state.html#gae56031a8c1d48e7802da32f5f39f5738">xkb_state::xkb_state_key_get_one_sym</a></div><div class="ttdeci">xkb_keysym_t xkb_state_key_get_one_sym(struct xkb_state *state, xkb_keycode_t key)</div><div class="ttdoc">Get the single keysym obtained from pressing a particular key in a given keyboard state.</div></div>
<div class="ttc" id="axkbcommon_8h_html_a79e604a22703391bdfe212cfc10ea007"><div class="ttname"><a href="xkbcommon_8h.html#a79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a></div><div class="ttdeci">uint32_t xkb_keysym_t</div><div class="ttdoc">A number used to represent the symbols generated from a key on a keyboard.</div><div class="ttdef"><b>Definition:</b> xkbcommon.h:195</div></div>
<div class="ttc" id="axkbcommon_8h_html_ac29aee92124c08d1953910ab28ee1997"><div class="ttname"><a href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a></div><div class="ttdeci">uint32_t xkb_keycode_t</div><div class="ttdoc">A number used to represent a physical key on a keyboard.</div><div class="ttdef"><b>Definition:</b> xkbcommon.h:134</div></div>
</div><!-- fragment --><p >We can see which keysym we got, and get its name:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> keysym_name[64];</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (keysym == XKB_KEY_Space)</div>
<div class="line">    &lt;got a space&gt;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__keysyms.html#ga63456bb7e56a2e7a3e02de86b19900ef">xkb_keysym_get_name</a>(keysym, keysym_name, <span class="keyword">sizeof</span>(keysym_name));</div>
<div class="ttc" id="agroup__keysyms_html_ga63456bb7e56a2e7a3e02de86b19900ef"><div class="ttname"><a href="group__keysyms.html#ga63456bb7e56a2e7a3e02de86b19900ef">xkb_keysym_get_name</a></div><div class="ttdeci">int xkb_keysym_get_name(xkb_keysym_t keysym, char *buffer, size_t size)</div><div class="ttdoc">Get the name of a keysym.</div></div>
</div><!-- fragment --><p >libxkbcommon also supports an extension to the classic XKB, whereby a single event can result in multiple keysyms. Here's how to use it:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_typedef" href="xkbcommon_8h.html#a79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a> *keysyms;</div>
<div class="line"><span class="keywordtype">int</span> num_keysyms;</div>
<div class="line"> </div>
<div class="line">num_keysyms = <a class="code hl_function" href="group__state.html#ga47311e7268935dd2fe3e6ef057a82cb0">xkb_state_key_get_syms</a>(state, keycode, &amp;keysyms);</div>
<div class="ttc" id="agroup__state_html_ga47311e7268935dd2fe3e6ef057a82cb0"><div class="ttname"><a href="group__state.html#ga47311e7268935dd2fe3e6ef057a82cb0">xkb_state::xkb_state_key_get_syms</a></div><div class="ttdeci">int xkb_state_key_get_syms(struct xkb_state *state, xkb_keycode_t key, const xkb_keysym_t **syms_out)</div><div class="ttdoc">Get the keysyms obtained from pressing a particular key in a given keyboard state.</div></div>
</div><!-- fragment --><p >We can also get a UTF-8 string representation for this key:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *buffer;</div>
<div class="line"><span class="keywordtype">int</span> size;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// First find the needed size; return value is the same as snprintf(3).</span></div>
<div class="line">size = <a class="code hl_function" href="group__state.html#ga0774b424063b45c88ec0354c77f9a247">xkb_state_key_get_utf8</a>(state, keycode, NULL, 0) + 1;</div>
<div class="line"><span class="keywordflow">if</span> (size &lt;= 1) &lt;nothing to <span class="keywordflow">do</span>&gt;</div>
<div class="line">buffer = &lt;allocate size bytes&gt;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__state.html#ga0774b424063b45c88ec0354c77f9a247">xkb_state_key_get_utf8</a>(state, keycode, buffer, size);</div>
<div class="ttc" id="agroup__state_html_ga0774b424063b45c88ec0354c77f9a247"><div class="ttname"><a href="group__state.html#ga0774b424063b45c88ec0354c77f9a247">xkb_state::xkb_state_key_get_utf8</a></div><div class="ttdeci">int xkb_state_key_get_utf8(struct xkb_state *state, xkb_keycode_t key, char *buffer, size_t size)</div><div class="ttdoc">Get the Unicode/UTF-8 string obtained from pressing a particular key in a given keyboard state.</div></div>
</div><!-- fragment --><p >Of course, we also need to keep the <code><a class="el" href="structxkb__state.html" title="Opaque keyboard state object.">xkb_state</a></code> up-to-date with the keyboard device, if we want to get the correct keysyms in the future.</p>
<p >If we are an evdev client, we must let the library know whether a key is pressed or released at any given time:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code hl_enumeration" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> changed;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (&lt;key press&gt;)</div>
<div class="line">    changed = <a class="code hl_function" href="group__state.html#gac554aa20743a621692c1a744a05e06ce">xkb_state_update_key</a>(state, keycode, <a class="code hl_enumvalue" href="group__state.html#gga631f03db07f30774659ab3f787b152e7a10b02b45f1fceae1b43bc69162f84678">XKB_KEY_DOWN</a>);</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (&lt;key release&gt;)</div>
<div class="line">    changed = <a class="code hl_function" href="group__state.html#gac554aa20743a621692c1a744a05e06ce">xkb_state_update_key</a>(state, keycode, <a class="code hl_enumvalue" href="group__state.html#gga631f03db07f30774659ab3f787b152e7aa685cb474cd090014d1049f74c3e3ec5">XKB_KEY_UP</a>);</div>
<div class="ttc" id="agroup__state_html_ga04e8eac0666cc64dee6f0d5a7a773a03"><div class="ttname"><a href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a></div><div class="ttdeci">xkb_state_component</div><div class="ttdoc">Modifier and layout types for state objects.</div><div class="ttdef"><b>Definition:</b> xkbcommon.h:1349</div></div>
<div class="ttc" id="agroup__state_html_gac554aa20743a621692c1a744a05e06ce"><div class="ttname"><a href="group__state.html#gac554aa20743a621692c1a744a05e06ce">xkb_state::xkb_state_update_key</a></div><div class="ttdeci">enum xkb_state_component xkb_state_update_key(struct xkb_state *state, xkb_keycode_t key, enum xkb_key_direction direction)</div><div class="ttdoc">Update the keyboard state to reflect a given key being pressed or released.</div></div>
<div class="ttc" id="agroup__state_html_gga631f03db07f30774659ab3f787b152e7a10b02b45f1fceae1b43bc69162f84678"><div class="ttname"><a href="group__state.html#gga631f03db07f30774659ab3f787b152e7a10b02b45f1fceae1b43bc69162f84678">XKB_KEY_DOWN</a></div><div class="ttdeci">@ XKB_KEY_DOWN</div><div class="ttdoc">The key was pressed.</div><div class="ttdef"><b>Definition:</b> xkbcommon.h:1339</div></div>
<div class="ttc" id="agroup__state_html_gga631f03db07f30774659ab3f787b152e7aa685cb474cd090014d1049f74c3e3ec5"><div class="ttname"><a href="group__state.html#gga631f03db07f30774659ab3f787b152e7aa685cb474cd090014d1049f74c3e3ec5">XKB_KEY_UP</a></div><div class="ttdeci">@ XKB_KEY_UP</div><div class="ttdoc">The key was released.</div><div class="ttdef"><b>Definition:</b> xkbcommon.h:1338</div></div>
</div><!-- fragment --><p >The <code>changed</code> return value tells us exactly which parts of the state have changed.</p>
<p >If it is a key-repeat event, we can ask the keymap what to do with it:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (&lt;key repeat&gt; &amp;&amp; !<a class="code hl_function" href="group__components.html#ga9d7f998efeca98b3afc7c257bbac90a8">xkb_keymap_key_repeats</a>(keymap, keycode))</div>
<div class="line">    &lt;discard <span class="keyword">event</span>&gt;</div>
<div class="ttc" id="agroup__components_html_ga9d7f998efeca98b3afc7c257bbac90a8"><div class="ttname"><a href="group__components.html#ga9d7f998efeca98b3afc7c257bbac90a8">xkb_keymap::xkb_keymap_key_repeats</a></div><div class="ttdeci">int xkb_keymap_key_repeats(struct xkb_keymap *keymap, xkb_keycode_t key)</div><div class="ttdoc">Determine whether a key should repeat or not.</div></div>
</div><!-- fragment --><p >On the other hand, if we are an X or Wayland client, the server already does the hard work for us. It notifies us when the device's state changes, and we can simply use what it tells us (the necessary information usually comes in a form of some "state changed" event):</p>
<div class="fragment"><div class="line">changed = <a class="code hl_function" href="group__state.html#ga566677517a286527e05efc5680adbe6b">xkb_state_update_mask</a>(state,</div>
<div class="line">                                event-&gt;depressed_mods,</div>
<div class="line">                                event-&gt;latched_mods,</div>
<div class="line">                                event-&gt;locked_mods,</div>
<div class="line">                                event-&gt;depressed_layout,</div>
<div class="line">                                event-&gt;latched_layout,</div>
<div class="line">                                event-&gt;locked_layout);</div>
<div class="ttc" id="agroup__state_html_ga566677517a286527e05efc5680adbe6b"><div class="ttname"><a href="group__state.html#ga566677517a286527e05efc5680adbe6b">xkb_state::xkb_state_update_mask</a></div><div class="ttdeci">enum xkb_state_component xkb_state_update_mask(struct xkb_state *state, xkb_mod_mask_t depressed_mods, xkb_mod_mask_t latched_mods, xkb_mod_mask_t locked_mods, xkb_layout_index_t depressed_layout, xkb_layout_index_t latched_layout, xkb_layout_index_t locked_layout)</div><div class="ttdoc">Update a keyboard state from a set of explicit masks.</div></div>
</div><!-- fragment --><p >Now that we have an always-up-to-date <code><a class="el" href="structxkb__state.html" title="Opaque keyboard state object.">xkb_state</a></code>, we can examine it. For example, we can check whether the Control modifier is active, or whether the Num Lock LED is active:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__state.html#gaaa5d800b0ae71ef78e412dc841d2e011">xkb_state_mod_name_is_active</a>(state, XKB_MOD_NAME_CTRL,</div>
<div class="line">                                 <a class="code hl_enumvalue" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03a2357b9f2490e89ab2d549695ea49de4f">XKB_STATE_MODS_EFFECTIVE</a>) &gt; 0)</div>
<div class="line">    &lt;The Control modifier is active&gt;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__state.html#gaebde139a6b3f964f137bfeadc4793166">xkb_state_led_name_is_active</a>(state, XKB_LED_NAME_NUM) &gt; 0)</div>
<div class="line">    &lt;The Num Lock LED is active&gt;</div>
<div class="ttc" id="agroup__state_html_gaaa5d800b0ae71ef78e412dc841d2e011"><div class="ttname"><a href="group__state.html#gaaa5d800b0ae71ef78e412dc841d2e011">xkb_state::xkb_state_mod_name_is_active</a></div><div class="ttdeci">int xkb_state_mod_name_is_active(struct xkb_state *state, const char *name, enum xkb_state_component type)</div><div class="ttdoc">Test whether a modifier is active in a given keyboard state by name.</div></div>
<div class="ttc" id="agroup__state_html_gaebde139a6b3f964f137bfeadc4793166"><div class="ttname"><a href="group__state.html#gaebde139a6b3f964f137bfeadc4793166">xkb_state::xkb_state_led_name_is_active</a></div><div class="ttdeci">int xkb_state_led_name_is_active(struct xkb_state *state, const char *name)</div><div class="ttdoc">Test whether a LED is active in a given keyboard state by name.</div></div>
<div class="ttc" id="agroup__state_html_gga04e8eac0666cc64dee6f0d5a7a773a03a2357b9f2490e89ab2d549695ea49de4f"><div class="ttname"><a href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03a2357b9f2490e89ab2d549695ea49de4f">XKB_STATE_MODS_EFFECTIVE</a></div><div class="ttdeci">@ XKB_STATE_MODS_EFFECTIVE</div><div class="ttdoc">Effective modifiers, i.e.</div><div class="ttdef"><b>Definition:</b> xkbcommon.h:1361</div></div>
</div><!-- fragment --><p >And that's it! Eventually, we should free the objects we've created:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__state.html#gacf5a9ee65857c4bdb7fbb5fbaa2dc115">xkb_state_unref</a>(state);</div>
<div class="line"><a class="code hl_function" href="group__keymap.html#gafb6b3d3fce63eb6dde6c1de0850fcf41">xkb_keymap_unref</a>(keymap);</div>
<div class="line"><a class="code hl_function" href="group__context.html#ga2c02737136dbc738b3c0db0a3a85e23a">xkb_context_unref</a>(ctx);</div>
<div class="ttc" id="agroup__context_html_ga2c02737136dbc738b3c0db0a3a85e23a"><div class="ttname"><a href="group__context.html#ga2c02737136dbc738b3c0db0a3a85e23a">xkb_context::xkb_context_unref</a></div><div class="ttdeci">void xkb_context_unref(struct xkb_context *context)</div><div class="ttdoc">Release a reference on a context, and possibly free it.</div></div>
<div class="ttc" id="agroup__keymap_html_gafb6b3d3fce63eb6dde6c1de0850fcf41"><div class="ttname"><a href="group__keymap.html#gafb6b3d3fce63eb6dde6c1de0850fcf41">xkb_keymap::xkb_keymap_unref</a></div><div class="ttdeci">void xkb_keymap_unref(struct xkb_keymap *keymap)</div><div class="ttdoc">Release a reference on a keymap, and possibly free it.</div></div>
<div class="ttc" id="agroup__state_html_gacf5a9ee65857c4bdb7fbb5fbaa2dc115"><div class="ttname"><a href="group__state.html#gacf5a9ee65857c4bdb7fbb5fbaa2dc115">xkb_state::xkb_state_unref</a></div><div class="ttdeci">void xkb_state_unref(struct xkb_state *state)</div><div class="ttdoc">Release a reference on a keybaord state object, and possibly free it.</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
