<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libxkbcommon: Keyboard State</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libxkbcommon
   &#160;<span id="projectnumber">0.8.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Keyboard State</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga631f03db07f30774659ab3f787b152e7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga631f03db07f30774659ab3f787b152e7">xkb_key_direction</a> { <br />
&#160;&#160;<a class="el" href="group__state.html#gga631f03db07f30774659ab3f787b152e7aa685cb474cd090014d1049f74c3e3ec5">XKB_KEY_UP</a>, 
<br />
&#160;&#160;<a class="el" href="group__state.html#gga631f03db07f30774659ab3f787b152e7a10b02b45f1fceae1b43bc69162f84678">XKB_KEY_DOWN</a>
<br />
 }</td></tr>
<tr class="separator:ga631f03db07f30774659ab3f787b152e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e8eac0666cc64dee6f0d5a7a773a03"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> { <br />
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03a82fc290363aaa579fa4957c7a72b8ce6">XKB_STATE_MODS_DEPRESSED</a> = (1 &lt;&lt; 0), 
<br />
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03af95b6c2b4979c32588abe8a960351434">XKB_STATE_MODS_LATCHED</a> = (1 &lt;&lt; 1), 
<br />
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03a95d6c496c78b6da162f7c78fbfc22bbc">XKB_STATE_MODS_LOCKED</a> = (1 &lt;&lt; 2), 
<br />
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03a2357b9f2490e89ab2d549695ea49de4f">XKB_STATE_MODS_EFFECTIVE</a> = (1 &lt;&lt; 3), 
<br />
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03ae2030e8ff7db5ee988920633e2b08e88">XKB_STATE_LAYOUT_DEPRESSED</a> = (1 &lt;&lt; 4), 
<br />
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03aaed45ef0bd8de351e096178c9b559345">XKB_STATE_LAYOUT_LATCHED</a> = (1 &lt;&lt; 5), 
<br />
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03a8b3f6503e09ad7a43a3be092cc7cfaca">XKB_STATE_LAYOUT_LOCKED</a> = (1 &lt;&lt; 6), 
<br />
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03a751a3a712f1a25225e13114266b29726">XKB_STATE_LAYOUT_EFFECTIVE</a> = (1 &lt;&lt; 7), 
<br />
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03a9d22ee4abdad31a3e24afdede62c3c6d">XKB_STATE_LEDS</a> = (1 &lt;&lt; 8)
<br />
 }</td></tr>
<tr class="separator:ga04e8eac0666cc64dee6f0d5a7a773a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf79b475eb908309ae1aa0e231b2c9aa8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a> { <br />
&#160;&#160;<a class="el" href="group__state.html#ggaf79b475eb908309ae1aa0e231b2c9aa8acc8bf019ef4abad1eff3762ab67fd1cf">XKB_STATE_MATCH_ANY</a> = (1 &lt;&lt; 0), 
<br />
&#160;&#160;<a class="el" href="group__state.html#ggaf79b475eb908309ae1aa0e231b2c9aa8a22afd2884474ad692b580a8b91413b5f">XKB_STATE_MATCH_ALL</a> = (1 &lt;&lt; 1), 
<br />
&#160;&#160;<a class="el" href="group__state.html#ggaf79b475eb908309ae1aa0e231b2c9aa8a4ae1c11ddb747718871afb24adbfb0d6">XKB_STATE_MATCH_NON_EXCLUSIVE</a> = (1 &lt;&lt; 16)
<br />
 }</td></tr>
<tr class="separator:gaf79b475eb908309ae1aa0e231b2c9aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66c3ae7ebaf4ccd60e5dab61dc1c29fb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga66c3ae7ebaf4ccd60e5dab61dc1c29fb">xkb_consumed_mode</a> { <br />
&#160;&#160;<a class="el" href="group__state.html#gga66c3ae7ebaf4ccd60e5dab61dc1c29fba14b9cdb7b905f3fdd7b0abcae2f597b1">XKB_CONSUMED_MODE_XKB</a>, 
<br />
&#160;&#160;<a class="el" href="group__state.html#gga66c3ae7ebaf4ccd60e5dab61dc1c29fba5e01146412303501dc7db2c2cf5c48d4">XKB_CONSUMED_MODE_GTK</a>
<br />
 }</td></tr>
<tr class="separator:ga66c3ae7ebaf4ccd60e5dab61dc1c29fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga281f0dc1cab624ab11e7c4d318d9d4ac"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga281f0dc1cab624ab11e7c4d318d9d4ac">xkb_state::xkb_state_new</a> (struct <a class="el" href="structxkb__keymap.html">xkb_keymap</a> *keymap)</td></tr>
<tr class="separator:ga281f0dc1cab624ab11e7c4d318d9d4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331c9404262721da3f657eb9300c0eef"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga331c9404262721da3f657eb9300c0eef">xkb_state::xkb_state_ref</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state)</td></tr>
<tr class="separator:ga331c9404262721da3f657eb9300c0eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf5a9ee65857c4bdb7fbb5fbaa2dc115"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gacf5a9ee65857c4bdb7fbb5fbaa2dc115">xkb_state::xkb_state_unref</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state)</td></tr>
<tr class="separator:gacf5a9ee65857c4bdb7fbb5fbaa2dc115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cad922d12dcfe040db29db77c88b876"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structxkb__keymap.html">xkb_keymap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga7cad922d12dcfe040db29db77c88b876">xkb_state::xkb_state_get_keymap</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state)</td></tr>
<tr class="separator:ga7cad922d12dcfe040db29db77c88b876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac554aa20743a621692c1a744a05e06ce"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gac554aa20743a621692c1a744a05e06ce">xkb_state::xkb_state_update_key</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, enum <a class="el" href="group__state.html#ga631f03db07f30774659ab3f787b152e7">xkb_key_direction</a> direction)</td></tr>
<tr class="separator:gac554aa20743a621692c1a744a05e06ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga566677517a286527e05efc5680adbe6b"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga566677517a286527e05efc5680adbe6b">xkb_state::xkb_state_update_mask</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> depressed_mods, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> latched_mods, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> locked_mods, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> depressed_layout, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> latched_layout, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> locked_layout)</td></tr>
<tr class="separator:ga566677517a286527e05efc5680adbe6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47311e7268935dd2fe3e6ef057a82cb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga47311e7268935dd2fe3e6ef057a82cb0">xkb_state::xkb_state_key_get_syms</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, const <a class="el" href="xkbcommon_8h.html#a79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a> **syms_out)</td></tr>
<tr class="separator:ga47311e7268935dd2fe3e6ef057a82cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0774b424063b45c88ec0354c77f9a247"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga0774b424063b45c88ec0354c77f9a247">xkb_state::xkb_state_key_get_utf8</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, char *buffer, size_t size)</td></tr>
<tr class="separator:ga0774b424063b45c88ec0354c77f9a247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga538418c3521c54f9f3559fcb3115ab04"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga538418c3521c54f9f3559fcb3115ab04">xkb_state::xkb_state_key_get_utf32</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key)</td></tr>
<tr class="separator:ga538418c3521c54f9f3559fcb3115ab04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae56031a8c1d48e7802da32f5f39f5738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xkbcommon_8h.html#a79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gae56031a8c1d48e7802da32f5f39f5738">xkb_state::xkb_state_key_get_one_sym</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key)</td></tr>
<tr class="separator:gae56031a8c1d48e7802da32f5f39f5738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac59ad6a608fb36055ecaf8d09449174f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gac59ad6a608fb36055ecaf8d09449174f">xkb_state::xkb_state_key_get_layout</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key)</td></tr>
<tr class="separator:gac59ad6a608fb36055ecaf8d09449174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec69be58f357c924b7c99c075631d74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xkbcommon_8h.html#a7eb38bea2a311b6ff033816278d5bbea">xkb_level_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga6ec69be58f357c924b7c99c075631d74">xkb_state::xkb_state_key_get_level</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> layout)</td></tr>
<tr class="separator:ga6ec69be58f357c924b7c99c075631d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3111bf59537a9df6cea8c05c4ddab93e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga3111bf59537a9df6cea8c05c4ddab93e">xkb_state::xkb_state_serialize_mods</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> components)</td></tr>
<tr class="separator:ga3111bf59537a9df6cea8c05c4ddab93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4b2d506dafd8aa68f41a3b81f7191fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gae4b2d506dafd8aa68f41a3b81f7191fb">xkb_state::xkb_state_serialize_layout</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> components)</td></tr>
<tr class="separator:gae4b2d506dafd8aa68f41a3b81f7191fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa5d800b0ae71ef78e412dc841d2e011"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gaaa5d800b0ae71ef78e412dc841d2e011">xkb_state::xkb_state_mod_name_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, const char *name, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type)</td></tr>
<tr class="separator:gaaa5d800b0ae71ef78e412dc841d2e011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bfe54d8ff430a61077458b4ba926c68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga7bfe54d8ff430a61077458b4ba926c68">xkb_state::xkb_state_mod_names_are_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type, enum <a class="el" href="group__state.html#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a> match,...)</td></tr>
<tr class="separator:ga7bfe54d8ff430a61077458b4ba926c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98b07d43090b761a79ac96967ae431c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga98b07d43090b761a79ac96967ae431c9">xkb_state::xkb_state_mod_index_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a> idx, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type)</td></tr>
<tr class="separator:ga98b07d43090b761a79ac96967ae431c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2101548a535fcee393b0ebadb341022"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gaa2101548a535fcee393b0ebadb341022">xkb_state::xkb_state_mod_indices_are_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type, enum <a class="el" href="group__state.html#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a> match,...)</td></tr>
<tr class="separator:gaa2101548a535fcee393b0ebadb341022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b119b99542fcad1787119191ba9e286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga5b119b99542fcad1787119191ba9e286">xkb_state::xkb_state_key_get_consumed_mods2</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, enum <a class="el" href="group__state.html#ga66c3ae7ebaf4ccd60e5dab61dc1c29fb">xkb_consumed_mode</a> mode)</td></tr>
<tr class="separator:ga5b119b99542fcad1787119191ba9e286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ae2a3bdd451bbf8dcee3080935aa0d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga3ae2a3bdd451bbf8dcee3080935aa0d3">xkb_state::xkb_state_key_get_consumed_mods</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key)</td></tr>
<tr class="separator:ga3ae2a3bdd451bbf8dcee3080935aa0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ffdf73b672aa3dc0a91394c65e3b90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga55ffdf73b672aa3dc0a91394c65e3b90">xkb_state::xkb_state_mod_index_is_consumed2</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, <a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a> idx, enum <a class="el" href="group__state.html#ga66c3ae7ebaf4ccd60e5dab61dc1c29fb">xkb_consumed_mode</a> mode)</td></tr>
<tr class="separator:ga55ffdf73b672aa3dc0a91394c65e3b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30061a16ebaccb7b34bb1ce7d106b001"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga30061a16ebaccb7b34bb1ce7d106b001">xkb_state::xkb_state_mod_index_is_consumed</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, <a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a> idx)</td></tr>
<tr class="separator:ga30061a16ebaccb7b34bb1ce7d106b001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd5639842c473778012afc75cebc076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gadcd5639842c473778012afc75cebc076">xkb_state::xkb_state_mod_mask_remove_consumed</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> mask)</td></tr>
<tr class="separator:gadcd5639842c473778012afc75cebc076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ffcb1f835d94cc39c5d8de16c5f2c37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga5ffcb1f835d94cc39c5d8de16c5f2c37">xkb_state::xkb_state_layout_name_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, const char *name, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type)</td></tr>
<tr class="separator:ga5ffcb1f835d94cc39c5d8de16c5f2c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4011df1f305b9167249d8ba217328f6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga4011df1f305b9167249d8ba217328f6c">xkb_state::xkb_state_layout_index_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> idx, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type)</td></tr>
<tr class="separator:ga4011df1f305b9167249d8ba217328f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebde139a6b3f964f137bfeadc4793166"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gaebde139a6b3f964f137bfeadc4793166">xkb_state::xkb_state_led_name_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, const char *name)</td></tr>
<tr class="separator:gaebde139a6b3f964f137bfeadc4793166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5a02e6f26ccd29b95e32d6fcb8f8149"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gaa5a02e6f26ccd29b95e32d6fcb8f8149">xkb_state::xkb_state_led_index_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#af6e951bdbcba8fb7e2532a8ebc6c9c87">xkb_led_index_t</a> idx)</td></tr>
<tr class="separator:gaa5a02e6f26ccd29b95e32d6fcb8f8149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Creating, destroying and manipulating keyboard state objects. </p>


<h3><a id="consumed-modifiers"></a>Consumed Modifiers</h3><div class="textblock"><p></p>
<p>Some functions, like <a class="el" href="group__state.html#ga47311e7268935dd2fe3e6ef057a82cb0" title="Get the keysyms obtained from pressing a particular key in a given keyboard state. ">xkb_state_key_get_syms()</a>, look at the state of the modifiers in the keymap and derive from it the correct shift level to use for the key. For example, in a US layout, pressing the key labeled &lt;A&gt; while the Shift modifier is active, generates the keysym 'A'. In this case, the Shift modifier is said to be "consumed". However, the Num Lock modifier does not affect this translation at all, even if it is active, so it is not consumed by this translation.</p>
<p>It may be desirable for some application to not reuse consumed modifiers for further processing, e.g. for hotkeys or keyboard shortcuts. To understand why, consider some requirements from a standard shortcut mechanism, and how they are implemented:</p>
<ol type="1">
<li>The shortcut's modifiers must match exactly to the state. For example, it is possible to bind separate actions to &lt;Alt&gt;&lt;Tab&gt; and to &lt;Alt&gt;&lt;Shift&gt;&lt;Tab&gt;. Further, if only &lt;Alt&gt;&lt;Tab&gt; is bound to an action, pressing &lt;Alt&gt;&lt;Shift&gt;&lt;Tab&gt; should not trigger the shortcut. Effectively, this means that the modifiers are compared using the equality operator (==).</li>
<li>Only relevant modifiers are considered for the matching. For example, Caps Lock and Num Lock should not generally affect the matching, e.g. when matching &lt;Alt&gt;&lt;Tab&gt; against the state, it does not matter whether Num Lock is active or not. These relevant, or "significant", modifiers usually include Alt, Control, Shift, Super and similar. Effectively, this means that non-significant modifiers are masked out, before doing the comparison as described above.</li>
<li>The matching must be independent of the layout/keymap. For example, the &lt;Plus&gt; (+) symbol is found on the first level on some layouts, but requires holding Shift on others. If you simply bind the action to the &lt;Plus&gt; keysym, it would work for the unshifted kind, but not for the others, because the match against Shift would fail. If you bind the action to &lt;Shift&gt;&lt;Plus&gt;, only the shifted kind would work. So what is needed is to recognize that Shift is used up in the translation of the keysym itself, and therefore should not be included in the matching. Effectively, this means that consumed modifiers (Shift in this example) are masked out as well, before doing the comparison.</li>
</ol>
<p>In summary, this is approximately how the matching would be performed: </p><div class="fragment"><div class="line">(keysym == shortcut_keysym) &amp;&amp;</div><div class="line">((state_mods &amp; ~consumed_mods &amp; significant_mods) == shortcut_mods)</div></div><!-- fragment --><p><code>state_mods</code> are the modifiers reported by <a class="el" href="group__state.html#ga98b07d43090b761a79ac96967ae431c9" title="Test whether a modifier is active in a given keyboard state by index. ">xkb_state_mod_index_is_active()</a> and similar functions. <code>consumed_mods</code> are the modifiers reported by <a class="el" href="group__state.html#ga30061a16ebaccb7b34bb1ce7d106b001" title="Same as xkb_state_mod_index_is_consumed2() with mode XKB_CONSUMED_MOD_XKB. ">xkb_state_mod_index_is_consumed()</a> and similar functions. <code>significant_mods</code> are decided upon by the application/toolkit/user; it is up to them to decide whether these are configurable or hard-coded.</p>
<p></p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga631f03db07f30774659ab3f787b152e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga631f03db07f30774659ab3f787b152e7">&#9670;&nbsp;</a></span>xkb_key_direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__state.html#ga631f03db07f30774659ab3f787b152e7">xkb_key_direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the direction of the key (press / release). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga631f03db07f30774659ab3f787b152e7aa685cb474cd090014d1049f74c3e3ec5"></a>XKB_KEY_UP&#160;</td><td class="fielddoc"><p>The key was released. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga631f03db07f30774659ab3f787b152e7a10b02b45f1fceae1b43bc69162f84678"></a>XKB_KEY_DOWN&#160;</td><td class="fielddoc"><p>The key was pressed. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga04e8eac0666cc64dee6f0d5a7a773a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04e8eac0666cc64dee6f0d5a7a773a03">&#9670;&nbsp;</a></span>xkb_state_component</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifier and layout types for state objects. </p>
<p>This enum is bitmaskable, e.g. (XKB_STATE_MODS_DEPRESSED | XKB_STATE_MODS_LATCHED) is valid to exclude locked modifiers.</p>
<p>In XKB, the DEPRESSED components are also known as 'base'. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03a82fc290363aaa579fa4957c7a72b8ce6"></a>XKB_STATE_MODS_DEPRESSED&#160;</td><td class="fielddoc"><p>Depressed modifiers, i.e. </p>
<p>a key is physically holding them. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03af95b6c2b4979c32588abe8a960351434"></a>XKB_STATE_MODS_LATCHED&#160;</td><td class="fielddoc"><p>Latched modifiers, i.e. </p>
<p>will be unset after the next non-modifier key press. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03a95d6c496c78b6da162f7c78fbfc22bbc"></a>XKB_STATE_MODS_LOCKED&#160;</td><td class="fielddoc"><p>Locked modifiers, i.e. </p>
<p>will be unset after the key provoking the lock has been pressed again. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03a2357b9f2490e89ab2d549695ea49de4f"></a>XKB_STATE_MODS_EFFECTIVE&#160;</td><td class="fielddoc"><p>Effective modifiers, i.e. </p>
<p>currently active and affect key processing (derived from the other state components). Use this unless you explictly care how the state came about. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03ae2030e8ff7db5ee988920633e2b08e88"></a>XKB_STATE_LAYOUT_DEPRESSED&#160;</td><td class="fielddoc"><p>Depressed layout, i.e. </p>
<p>a key is physically holding it. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03aaed45ef0bd8de351e096178c9b559345"></a>XKB_STATE_LAYOUT_LATCHED&#160;</td><td class="fielddoc"><p>Latched layout, i.e. </p>
<p>will be unset after the next non-modifier key press. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03a8b3f6503e09ad7a43a3be092cc7cfaca"></a>XKB_STATE_LAYOUT_LOCKED&#160;</td><td class="fielddoc"><p>Locked layout, i.e. </p>
<p>will be unset after the key provoking the lock has been pressed again. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03a751a3a712f1a25225e13114266b29726"></a>XKB_STATE_LAYOUT_EFFECTIVE&#160;</td><td class="fielddoc"><p>Effective layout, i.e. </p>
<p>currently active and affects key processing (derived from the other state components). Use this unless you explictly care how the state came about. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03a9d22ee4abdad31a3e24afdede62c3c6d"></a>XKB_STATE_LEDS&#160;</td><td class="fielddoc"><p>LEDs (derived from the other state components). </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf79b475eb908309ae1aa0e231b2c9aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf79b475eb908309ae1aa0e231b2c9aa8">&#9670;&nbsp;</a></span>xkb_state_match</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__state.html#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match flags for <a class="el" href="group__state.html#gaa2101548a535fcee393b0ebadb341022" title="Test whether a set of modifiers are active in a given keyboard state by index. ">xkb_state_mod_indices_are_active()</a> and <a class="el" href="group__state.html#ga7bfe54d8ff430a61077458b4ba926c68" title="Test whether a set of modifiers are active in a given keyboard state by name. ">xkb_state_mod_names_are_active()</a>, specifying the conditions for a successful match. </p>
<p>XKB_STATE_MATCH_NON_EXCLUSIVE is bitmaskable with the other modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf79b475eb908309ae1aa0e231b2c9aa8acc8bf019ef4abad1eff3762ab67fd1cf"></a>XKB_STATE_MATCH_ANY&#160;</td><td class="fielddoc"><p>Returns true if any of the modifiers are active. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf79b475eb908309ae1aa0e231b2c9aa8a22afd2884474ad692b580a8b91413b5f"></a>XKB_STATE_MATCH_ALL&#160;</td><td class="fielddoc"><p>Returns true if all of the modifiers are active. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf79b475eb908309ae1aa0e231b2c9aa8a4ae1c11ddb747718871afb24adbfb0d6"></a>XKB_STATE_MATCH_NON_EXCLUSIVE&#160;</td><td class="fielddoc"><p>Makes matching non-exclusive, i.e. </p>
<p>will not return false if a modifier not specified in the arguments is active. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga66c3ae7ebaf4ccd60e5dab61dc1c29fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66c3ae7ebaf4ccd60e5dab61dc1c29fb">&#9670;&nbsp;</a></span>xkb_consumed_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__state.html#ga66c3ae7ebaf4ccd60e5dab61dc1c29fb">xkb_consumed_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumed modifiers mode. </p>
<p>There are several possible methods for deciding which modifiers are consumed and which are not, each applicable for different systems or situations. The mode selects the method to use.</p>
<p>Keep in mind that in all methods, the keymap may decide to "preserve" a modifier, meaning it is not reported as consumed even if it would have otherwise. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga66c3ae7ebaf4ccd60e5dab61dc1c29fba14b9cdb7b905f3fdd7b0abcae2f597b1"></a>XKB_CONSUMED_MODE_XKB&#160;</td><td class="fielddoc"><p>This is the mode defined in the XKB specification and used by libX11. </p>
<p>A modifier is consumed if and only if it <em>may affect</em> key translation.</p>
<p>For example, if <code>Control+Alt+&lt;Backspace&gt;</code> produces some assigned keysym, then when pressing just <code>&lt;Backspace&gt;</code>, <code>Control</code> and <code>Alt</code> are consumed, even though they are not active, since if they <em>were</em> active they would have affected key translation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga66c3ae7ebaf4ccd60e5dab61dc1c29fba5e01146412303501dc7db2c2cf5c48d4"></a>XKB_CONSUMED_MODE_GTK&#160;</td><td class="fielddoc"><p>This is the mode used by the GTK+ toolkit. </p>
<p>The mode consists of the following two independent heuristics:</p>
<ul>
<li>The currently active set of modifiers, excluding modifiers which do not affect the key (as described for <a class="el" href="group__state.html#gga66c3ae7ebaf4ccd60e5dab61dc1c29fba14b9cdb7b905f3fdd7b0abcae2f597b1">XKB_CONSUMED_MODE_XKB</a>), are considered consumed, if the keysyms produced when all of them are active are different from the keysyms produced when no modifiers are active.</li>
<li>A single modifier is considered consumed if the keysyms produced for the key when it is the only active modifier are different from the keysyms produced when no modifiers are active. </li>
</ul>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga281f0dc1cab624ab11e7c4d318d9d4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga281f0dc1cab624ab11e7c4d318d9d4ac">&#9670;&nbsp;</a></span>xkb_state_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structxkb__state.html">xkb_state</a> * xkb_state_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__keymap.html">xkb_keymap</a> *&#160;</td>
          <td class="paramname"><em>keymap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new keyboard state object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keymap</td><td>The keymap which the state will use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new keyboard state object, or NULL on failure. </dd></dl>

</div>
</div>
<a id="ga331c9404262721da3f657eb9300c0eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga331c9404262721da3f657eb9300c0eef">&#9670;&nbsp;</a></span>xkb_state_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structxkb__state.html">xkb_state</a> * xkb_state_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a new reference on a keyboard state object. </p>
<dl class="section return"><dt>Returns</dt><dd>The passed in object. </dd></dl>

</div>
</div>
<a id="gacf5a9ee65857c4bdb7fbb5fbaa2dc115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf5a9ee65857c4bdb7fbb5fbaa2dc115">&#9670;&nbsp;</a></span>xkb_state_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xkb_state_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a reference on a keybaord state object, and possibly free it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state. If it is NULL, this function does nothing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7cad922d12dcfe040db29db77c88b876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cad922d12dcfe040db29db77c88b876">&#9670;&nbsp;</a></span>xkb_state_get_keymap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structxkb__keymap.html">xkb_keymap</a> * xkb_state_get_keymap </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the keymap which a keyboard state object is using. </p>
<dl class="section return"><dt>Returns</dt><dd>The keymap which was passed to <a class="el" href="group__state.html#ga281f0dc1cab624ab11e7c4d318d9d4ac" title="Create a new keyboard state object. ">xkb_state_new()</a> when creating this state object.</dd></dl>
<p>This function does not take a new reference on the keymap; you must explicitly reference it yourself if you plan to use it beyond the lifetime of the state. </p>

</div>
</div>
<a id="gac554aa20743a621692c1a744a05e06ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac554aa20743a621692c1a744a05e06ce">&#9670;&nbsp;</a></span>xkb_state_update_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> xkb_state_update_key </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga631f03db07f30774659ab3f787b152e7">xkb_key_direction</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the keyboard state to reflect a given key being pressed or released. </p>
<p>This entry point is intended for programs which track the keyboard state explictly (like an evdev client). If the state is serialized to you by a master process (like a Wayland compositor) using functions like <a class="el" href="group__state.html#ga3111bf59537a9df6cea8c05c4ddab93e" title="The counterpart to xkb_state_update_mask for modifiers, to be used on the server side of serializatio...">xkb_state_serialize_mods()</a>, you should use <a class="el" href="group__state.html#ga566677517a286527e05efc5680adbe6b" title="Update a keyboard state from a set of explicit masks. ">xkb_state_update_mask()</a> instead. The two functins should not generally be used together.</p>
<p>A series of calls to this function should be consistent; that is, a call with XKB_KEY_DOWN for a key should be matched by an XKB_KEY_UP; if a key is pressed twice, it should be released twice; etc. Otherwise (e.g. due to missed input events), situations like "stuck modifiers" may occur.</p>
<p>This function is often used in conjunction with the function <a class="el" href="group__state.html#ga47311e7268935dd2fe3e6ef057a82cb0" title="Get the keysyms obtained from pressing a particular key in a given keyboard state. ">xkb_state_key_get_syms()</a> (or <a class="el" href="group__state.html#gae56031a8c1d48e7802da32f5f39f5738" title="Get the single keysym obtained from pressing a particular key in a given keyboard state...">xkb_state_key_get_one_sym()</a>), for example, when handling a key event. In this case, you should prefer to get the keysyms <em>before</em> updating the key, such that the keysyms reported for the key event are not affected by the event itself. This is the conventional behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>A mask of state components that have changed as a result of the update. If nothing in the state has changed, returns 0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__state.html#ga566677517a286527e05efc5680adbe6b" title="Update a keyboard state from a set of explicit masks. ">xkb_state_update_mask()</a> </dd></dl>

</div>
</div>
<a id="ga566677517a286527e05efc5680adbe6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga566677517a286527e05efc5680adbe6b">&#9670;&nbsp;</a></span>xkb_state_update_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> xkb_state_update_mask </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td>
          <td class="paramname"><em>depressed_mods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td>
          <td class="paramname"><em>latched_mods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td>
          <td class="paramname"><em>locked_mods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td>
          <td class="paramname"><em>depressed_layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td>
          <td class="paramname"><em>latched_layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td>
          <td class="paramname"><em>locked_layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a keyboard state from a set of explicit masks. </p>
<p>This entry point is intended for window systems and the like, where a master process holds an <a class="el" href="structxkb__state.html" title="Opaque keyboard state object. ">xkb_state</a>, then serializes it over a wire protocol, and clients then use the serialization to feed in to their own <a class="el" href="structxkb__state.html" title="Opaque keyboard state object. ">xkb_state</a>.</p>
<p>All parameters must always be passed, or the resulting state may be incoherent.</p>
<p>The serialization is lossy and will not survive round trips; it must only be used to feed slave state objects, and must not be used to update the master state.</p>
<p>If you do not fit the description above, you should use <a class="el" href="group__state.html#gac554aa20743a621692c1a744a05e06ce" title="Update the keyboard state to reflect a given key being pressed or released. ">xkb_state_update_key()</a> instead. The two functions should not generally be used together.</p>
<dl class="section return"><dt>Returns</dt><dd>A mask of state components that have changed as a result of the update. If nothing in the state has changed, returns 0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03" title="Modifier and layout types for state objects. ">xkb_state_component</a> </dd>
<dd>
<a class="el" href="group__state.html#gac554aa20743a621692c1a744a05e06ce" title="Update the keyboard state to reflect a given key being pressed or released. ">xkb_state_update_key</a> </dd></dl>

</div>
</div>
<a id="ga47311e7268935dd2fe3e6ef057a82cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47311e7268935dd2fe3e6ef057a82cb0">&#9670;&nbsp;</a></span>xkb_state_key_get_syms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_key_get_syms </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="xkbcommon_8h.html#a79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a> **&#160;</td>
          <td class="paramname"><em>syms_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the keysyms obtained from pressing a particular key in a given keyboard state. </p>
<p>Get the keysyms for a key according to the current active layout, modifiers and shift level for the key, as determined by a keyboard state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The keyboard state object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The keycode of the key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">syms_out</td><td>An immutable array of keysyms corresponding the key in the given keyboard state.</td></tr>
  </table>
  </dd>
</dl>
<p>As an extension to XKB, this function can return more than one keysym. If you do not want to handle this case, you can use <a class="el" href="group__state.html#gae56031a8c1d48e7802da32f5f39f5738" title="Get the single keysym obtained from pressing a particular key in a given keyboard state...">xkb_state_key_get_one_sym()</a> for a simpler interface.</p>
<p>This function does not perform any <a class="el" href="group__keysyms.html">Keysym Transformations</a>. (This might change).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of keysyms in the syms_out array. If no keysyms are produced by the key in the given keyboard state, returns 0 and sets syms_out to NULL. </dd></dl>

</div>
</div>
<a id="ga0774b424063b45c88ec0354c77f9a247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0774b424063b45c88ec0354c77f9a247">&#9670;&nbsp;</a></span>xkb_state_key_get_utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_key_get_utf8 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Unicode/UTF-8 string obtained from pressing a particular key in a given keyboard state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The keyboard state object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The keycode of the key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>A buffer to write the string into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the buffer passed is too small, the string is truncated (though still NUL-terminated).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes required for the string, excluding the NUL byte. If there is nothing to write, returns 0.</dd></dl>
<p>You may check if truncation has occurred by comparing the return value with the size of <code>buffer</code>, similarly to the snprintf(3) function. You may safely pass NULL and 0 to <code>buffer</code> and <code>size</code> to find the required size (without the NUL-byte).</p>
<p>This function performs Capitalization and Control <a class="el" href="group__keysyms.html">Keysym Transformations</a>.</p>
<dl class="section since"><dt>Since</dt><dd>0.4.1 </dd></dl>

</div>
</div>
<a id="ga538418c3521c54f9f3559fcb3115ab04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga538418c3521c54f9f3559fcb3115ab04">&#9670;&nbsp;</a></span>xkb_state_key_get_utf32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t xkb_state_key_get_utf32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Unicode/UTF-32 codepoint obtained from pressing a particular key in a a given keyboard state. </p>
<dl class="section return"><dt>Returns</dt><dd>The UTF-32 representation for the key, if it consists of only a single codepoint. Otherwise, returns 0.</dd></dl>
<p>This function performs Capitalization and Control <a class="el" href="group__keysyms.html">Keysym Transformations</a>.</p>
<dl class="section since"><dt>Since</dt><dd>0.4.1 </dd></dl>

</div>
</div>
<a id="gae56031a8c1d48e7802da32f5f39f5738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae56031a8c1d48e7802da32f5f39f5738">&#9670;&nbsp;</a></span>xkb_state_key_get_one_sym()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xkbcommon_8h.html#a79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a> xkb_state_key_get_one_sym </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the single keysym obtained from pressing a particular key in a given keyboard state. </p>
<p>This function is similar to <a class="el" href="group__state.html#ga47311e7268935dd2fe3e6ef057a82cb0" title="Get the keysyms obtained from pressing a particular key in a given keyboard state. ">xkb_state_key_get_syms()</a>, but intended for users which cannot or do not want to handle the case where multiple keysyms are returned (in which case this function is preferred).</p>
<dl class="section return"><dt>Returns</dt><dd>The keysym. If the key does not have exactly one keysym, returns XKB_KEY_NoSymbol</dd></dl>
<p>This function performs Capitalization <a class="el" href="group__keysyms.html">Keysym Transformations</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__state.html#ga47311e7268935dd2fe3e6ef057a82cb0" title="Get the keysyms obtained from pressing a particular key in a given keyboard state. ">xkb_state_key_get_syms()</a> </dd></dl>

</div>
</div>
<a id="gac59ad6a608fb36055ecaf8d09449174f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac59ad6a608fb36055ecaf8d09449174f">&#9670;&nbsp;</a></span>xkb_state_key_get_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> xkb_state_key_get_layout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the effective layout index for a key in a given keyboard state. </p>
<dl class="section return"><dt>Returns</dt><dd>The layout index for the key in the given keyboard state. If the given keycode is invalid, or if the key is not included in any layout at all, returns XKB_LAYOUT_INVALID.</dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd>If the returned layout is valid, the following always holds: <div class="fragment"><div class="line"><a class="code" href="group__state.html#gac59ad6a608fb36055ecaf8d09449174f">xkb_state_key_get_layout</a>(state, key) &lt; xkb_keymap_num_layouts_for_key(keymap, key)</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga6ec69be58f357c924b7c99c075631d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ec69be58f357c924b7c99c075631d74">&#9670;&nbsp;</a></span>xkb_state_key_get_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xkbcommon_8h.html#a7eb38bea2a311b6ff033816278d5bbea">xkb_level_index_t</a> xkb_state_key_get_level </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the effective shift level for a key in a given keyboard state and layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">key</td><td>The keycode of the key. </td></tr>
    <tr><td class="paramname">layout</td><td>The layout for which to get the shift level. This must be smaller than: <div class="fragment"><div class="line">xkb_keymap_num_layouts_for_key(keymap, key) </div></div><!-- fragment --> usually it would be: <div class="fragment"><div class="line"><a class="code" href="group__state.html#gac59ad6a608fb36055ecaf8d09449174f">xkb_state_key_get_layout</a>(state, key) </div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shift level index. If the key or layout are invalid, returns XKB_LEVEL_INVALID.</dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd>If the returned level is valid, the following always holds: <div class="fragment"><div class="line"><a class="code" href="group__state.html#ga6ec69be58f357c924b7c99c075631d74">xkb_state_key_get_level</a>(state, key, layout) &lt; xkb_keymap_num_levels_for_key(keymap, key, layout)</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga3111bf59537a9df6cea8c05c4ddab93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3111bf59537a9df6cea8c05c4ddab93e">&#9670;&nbsp;</a></span>xkb_state_serialize_mods()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> xkb_state_serialize_mods </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The counterpart to xkb_state_update_mask for modifiers, to be used on the server side of serialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">components</td><td>A mask of the modifier state components to serialize. State components other than XKB_STATE_MODS_* are ignored. If XKB_STATE_MODS_EFFECTIVE is included, all other state components are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A xkb_mod_mask_t representing the given components of the modifier state.</dd></dl>
<p>This function should not be used in regular clients; please use the xkb_state_mod_*_is_active API instead. </p>

</div>
</div>
<a id="gae4b2d506dafd8aa68f41a3b81f7191fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4b2d506dafd8aa68f41a3b81f7191fb">&#9670;&nbsp;</a></span>xkb_state_serialize_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> xkb_state_serialize_layout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The counterpart to xkb_state_update_mask for layouts, to be used on the server side of serialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">components</td><td>A mask of the layout state components to serialize. State components other than XKB_STATE_LAYOUT_* are ignored. If XKB_STATE_LAYOUT_EFFECTIVE is included, all other state components are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A layout index representing the given components of the layout state.</dd></dl>
<p>This function should not be used in regular clients; please use the xkb_state_layout_*_is_active API instead. </p>

</div>
</div>
<a id="gaaa5d800b0ae71ef78e412dc841d2e011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa5d800b0ae71ef78e412dc841d2e011">&#9670;&nbsp;</a></span>xkb_state_mod_name_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_mod_name_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a modifier is active in a given keyboard state by name. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifier is active, 0 if it is not. If the modifier name does not exist in the keymap, returns -1. </dd></dl>

</div>
</div>
<a id="ga7bfe54d8ff430a61077458b4ba926c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bfe54d8ff430a61077458b4ba926c68">&#9670;&nbsp;</a></span>xkb_state_mod_names_are_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_mod_names_are_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a>&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a set of modifiers are active in a given keyboard state by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">type</td><td>The component of the state against which to match the given modifiers. </td></tr>
    <tr><td class="paramname">match</td><td>The manner by which to match the state against the given modifiers. </td></tr>
    <tr><td class="paramname">...</td><td>The set of of modifier names to test, terminated by a NULL argument (sentinel).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifiers are active, 0 if they are not. If any of the modifier names do not exist in the keymap, returns -1. </dd></dl>

</div>
</div>
<a id="ga98b07d43090b761a79ac96967ae431c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98b07d43090b761a79ac96967ae431c9">&#9670;&nbsp;</a></span>xkb_state_mod_index_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_mod_index_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a modifier is active in a given keyboard state by index. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifier is active, 0 if it is not. If the modifier index is invalid in the keymap, returns -1. </dd></dl>

</div>
</div>
<a id="gaa2101548a535fcee393b0ebadb341022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2101548a535fcee393b0ebadb341022">&#9670;&nbsp;</a></span>xkb_state_mod_indices_are_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_mod_indices_are_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a>&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a set of modifiers are active in a given keyboard state by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">type</td><td>The component of the state against which to match the given modifiers. </td></tr>
    <tr><td class="paramname">match</td><td>The manner by which to match the state against the given modifiers. </td></tr>
    <tr><td class="paramname">...</td><td>The set of of modifier indices to test, terminated by a XKB_MOD_INVALID argument (sentinel).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifiers are active, 0 if they are not. If any of the modifier indices are invalid in the keymap, returns -1. </dd></dl>

</div>
</div>
<a id="ga5b119b99542fcad1787119191ba9e286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b119b99542fcad1787119191ba9e286">&#9670;&nbsp;</a></span>xkb_state_key_get_consumed_mods2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> xkb_state_key_get_consumed_mods2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga66c3ae7ebaf4ccd60e5dab61dc1c29fb">xkb_consumed_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mask of modifiers consumed by translating a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">key</td><td>The keycode of the key. </td></tr>
    <tr><td class="paramname">mode</td><td>The consumed modifiers mode to use; see enum description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mask of the consumed modifiers.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.7.0 </dd></dl>

</div>
</div>
<a id="ga3ae2a3bdd451bbf8dcee3080935aa0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ae2a3bdd451bbf8dcee3080935aa0d3">&#9670;&nbsp;</a></span>xkb_state_key_get_consumed_mods()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> xkb_state_key_get_consumed_mods </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__state.html#ga5b119b99542fcad1787119191ba9e286" title="Get the mask of modifiers consumed by translating a given key. ">xkb_state_key_get_consumed_mods2()</a> with mode XKB_CONSUMED_MODE_XKB. </p>
<dl class="section since"><dt>Since</dt><dd>0.4.1 </dd></dl>

</div>
</div>
<a id="ga55ffdf73b672aa3dc0a91394c65e3b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55ffdf73b672aa3dc0a91394c65e3b90">&#9670;&nbsp;</a></span>xkb_state_mod_index_is_consumed2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_mod_index_is_consumed2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga66c3ae7ebaf4ccd60e5dab61dc1c29fb">xkb_consumed_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a modifier is consumed by keyboard state translation for a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">key</td><td>The keycode of the key. </td></tr>
    <tr><td class="paramname">idx</td><td>The index of the modifier to check. </td></tr>
    <tr><td class="paramname">mode</td><td>The consumed modifiers mode to use; see enum description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifier is consumed, 0 if it is not. If the modifier index is not valid in the keymap, returns -1.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__state.html#gadcd5639842c473778012afc75cebc076" title="Remove consumed modifiers from a modifier mask for a key. ">xkb_state_mod_mask_remove_consumed()</a> </dd>
<dd>
<a class="el" href="group__state.html#ga3ae2a3bdd451bbf8dcee3080935aa0d3" title="Same as xkb_state_key_get_consumed_mods2() with mode XKB_CONSUMED_MODE_XKB. ">xkb_state_key_get_consumed_mods()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.7.0 </dd></dl>

</div>
</div>
<a id="ga30061a16ebaccb7b34bb1ce7d106b001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30061a16ebaccb7b34bb1ce7d106b001">&#9670;&nbsp;</a></span>xkb_state_mod_index_is_consumed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_mod_index_is_consumed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__state.html#ga55ffdf73b672aa3dc0a91394c65e3b90" title="Test whether a modifier is consumed by keyboard state translation for a key. ">xkb_state_mod_index_is_consumed2()</a> with mode XKB_CONSUMED_MOD_XKB. </p>
<dl class="section since"><dt>Since</dt><dd>0.4.1 </dd></dl>

</div>
</div>
<a id="gadcd5639842c473778012afc75cebc076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcd5639842c473778012afc75cebc076">&#9670;&nbsp;</a></span>xkb_state_mod_mask_remove_consumed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> xkb_state_mod_mask_remove_consumed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove consumed modifiers from a modifier mask for a key. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__state.html#ga5b119b99542fcad1787119191ba9e286" title="Get the mask of modifiers consumed by translating a given key. ">xkb_state_key_get_consumed_mods2()</a> instead.</dd></dl>
<p>Takes the given modifier mask, and removes all modifiers which are consumed for that particular key (as in <a class="el" href="group__state.html#ga30061a16ebaccb7b34bb1ce7d106b001" title="Same as xkb_state_mod_index_is_consumed2() with mode XKB_CONSUMED_MOD_XKB. ">xkb_state_mod_index_is_consumed()</a>).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__state.html#ga30061a16ebaccb7b34bb1ce7d106b001" title="Same as xkb_state_mod_index_is_consumed2() with mode XKB_CONSUMED_MOD_XKB. ">xkb_state_mod_index_is_consumed()</a> </dd></dl>

</div>
</div>
<a id="ga5ffcb1f835d94cc39c5d8de16c5f2c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ffcb1f835d94cc39c5d8de16c5f2c37">&#9670;&nbsp;</a></span>xkb_state_layout_name_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_layout_name_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a layout is active in a given keyboard state by name. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the layout is active, 0 if it is not. If no layout with this name exists in the keymap, return -1.</dd></dl>
<p>If multiple layouts in the keymap have this name, the one with the lowest index is tested.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39" title="Index of a keyboard layout. ">xkb_layout_index_t</a> </dd></dl>

</div>
</div>
<a id="ga4011df1f305b9167249d8ba217328f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4011df1f305b9167249d8ba217328f6c">&#9670;&nbsp;</a></span>xkb_state_layout_index_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_layout_index_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a layout is active in a given keyboard state by index. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the layout is active, 0 if it is not. If the layout index is not valid in the keymap, returns -1.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39" title="Index of a keyboard layout. ">xkb_layout_index_t</a> </dd></dl>

</div>
</div>
<a id="gaebde139a6b3f964f137bfeadc4793166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebde139a6b3f964f137bfeadc4793166">&#9670;&nbsp;</a></span>xkb_state_led_name_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_led_name_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a LED is active in a given keyboard state by name. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the LED is active, 0 if it not. If no LED with this name exists in the keymap, returns -1.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xkbcommon_8h.html#af6e951bdbcba8fb7e2532a8ebc6c9c87" title="Index of a keyboard LED. ">xkb_led_index_t</a> </dd></dl>

</div>
</div>
<a id="gaa5a02e6f26ccd29b95e32d6fcb8f8149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5a02e6f26ccd29b95e32d6fcb8f8149">&#9670;&nbsp;</a></span>xkb_state_led_index_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_led_index_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#af6e951bdbcba8fb7e2532a8ebc6c9c87">xkb_led_index_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a LED is active in a given keyboard state by index. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the LED is active, 0 if it not. If the LED index is not valid in the keymap, returns -1.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xkbcommon_8h.html#af6e951bdbcba8fb7e2532a8ebc6c9c87" title="Index of a keyboard LED. ">xkb_led_index_t</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
