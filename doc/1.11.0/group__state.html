<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libxkbcommon: Keyboard State</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libxkbcommon<span id="projectnumber">&#160;1.11.0</span>
   </div>
   <div id="projectbrief">Library implementing the XKB specification for parsing                           keyboard descriptions and handling keyboard state</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Keyboard State</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga631f03db07f30774659ab3f787b152e7" id="r_ga631f03db07f30774659ab3f787b152e7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga631f03db07f30774659ab3f787b152e7">xkb_key_direction</a> { <br />
&#160;&#160;<a class="el" href="#gga631f03db07f30774659ab3f787b152e7aa685cb474cd090014d1049f74c3e3ec5">XKB_KEY_UP</a>
, <br />
&#160;&#160;<a class="el" href="#gga631f03db07f30774659ab3f787b152e7a10b02b45f1fceae1b43bc69162f84678">XKB_KEY_DOWN</a>
<br />
 }</td></tr>
<tr class="separator:ga631f03db07f30774659ab3f787b152e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e8eac0666cc64dee6f0d5a7a773a03" id="r_ga04e8eac0666cc64dee6f0d5a7a773a03"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> { <br />
&#160;&#160;<a class="el" href="#gga04e8eac0666cc64dee6f0d5a7a773a03a82fc290363aaa579fa4957c7a72b8ce6">XKB_STATE_MODS_DEPRESSED</a> = (1 &lt;&lt; 0)
, <br />
&#160;&#160;<a class="el" href="#gga04e8eac0666cc64dee6f0d5a7a773a03af95b6c2b4979c32588abe8a960351434">XKB_STATE_MODS_LATCHED</a> = (1 &lt;&lt; 1)
, <br />
&#160;&#160;<a class="el" href="#gga04e8eac0666cc64dee6f0d5a7a773a03a95d6c496c78b6da162f7c78fbfc22bbc">XKB_STATE_MODS_LOCKED</a> = (1 &lt;&lt; 2)
, <br />
&#160;&#160;<a class="el" href="#gga04e8eac0666cc64dee6f0d5a7a773a03a2357b9f2490e89ab2d549695ea49de4f">XKB_STATE_MODS_EFFECTIVE</a> = (1 &lt;&lt; 3)
, <br />
&#160;&#160;<a class="el" href="#gga04e8eac0666cc64dee6f0d5a7a773a03ae2030e8ff7db5ee988920633e2b08e88">XKB_STATE_LAYOUT_DEPRESSED</a> = (1 &lt;&lt; 4)
, <br />
&#160;&#160;<a class="el" href="#gga04e8eac0666cc64dee6f0d5a7a773a03aaed45ef0bd8de351e096178c9b559345">XKB_STATE_LAYOUT_LATCHED</a> = (1 &lt;&lt; 5)
, <br />
&#160;&#160;<a class="el" href="#gga04e8eac0666cc64dee6f0d5a7a773a03a8b3f6503e09ad7a43a3be092cc7cfaca">XKB_STATE_LAYOUT_LOCKED</a> = (1 &lt;&lt; 6)
, <br />
&#160;&#160;<a class="el" href="#gga04e8eac0666cc64dee6f0d5a7a773a03a751a3a712f1a25225e13114266b29726">XKB_STATE_LAYOUT_EFFECTIVE</a> = (1 &lt;&lt; 7)
, <br />
&#160;&#160;<a class="el" href="#gga04e8eac0666cc64dee6f0d5a7a773a03a9d22ee4abdad31a3e24afdede62c3c6d">XKB_STATE_LEDS</a> = (1 &lt;&lt; 8)
<br />
 }</td></tr>
<tr class="separator:ga04e8eac0666cc64dee6f0d5a7a773a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf79b475eb908309ae1aa0e231b2c9aa8" id="r_gaf79b475eb908309ae1aa0e231b2c9aa8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a> { <br />
&#160;&#160;<a class="el" href="#ggaf79b475eb908309ae1aa0e231b2c9aa8acc8bf019ef4abad1eff3762ab67fd1cf">XKB_STATE_MATCH_ANY</a> = (1 &lt;&lt; 0)
, <br />
&#160;&#160;<a class="el" href="#ggaf79b475eb908309ae1aa0e231b2c9aa8a22afd2884474ad692b580a8b91413b5f">XKB_STATE_MATCH_ALL</a> = (1 &lt;&lt; 1)
, <br />
&#160;&#160;<a class="el" href="#ggaf79b475eb908309ae1aa0e231b2c9aa8a4ae1c11ddb747718871afb24adbfb0d6">XKB_STATE_MATCH_NON_EXCLUSIVE</a> = (1 &lt;&lt; 16)
<br />
 }</td></tr>
<tr class="separator:gaf79b475eb908309ae1aa0e231b2c9aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66c3ae7ebaf4ccd60e5dab61dc1c29fb" id="r_ga66c3ae7ebaf4ccd60e5dab61dc1c29fb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga66c3ae7ebaf4ccd60e5dab61dc1c29fb">xkb_consumed_mode</a> { <br />
&#160;&#160;<a class="el" href="#gga66c3ae7ebaf4ccd60e5dab61dc1c29fba14b9cdb7b905f3fdd7b0abcae2f597b1">XKB_CONSUMED_MODE_XKB</a>
, <br />
&#160;&#160;<a class="el" href="#gga66c3ae7ebaf4ccd60e5dab61dc1c29fba5e01146412303501dc7db2c2cf5c48d4">XKB_CONSUMED_MODE_GTK</a>
<br />
 }</td></tr>
<tr class="separator:ga66c3ae7ebaf4ccd60e5dab61dc1c29fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7981d274ae2e1d720bd55e0d81a4da5c" id="r_ga7981d274ae2e1d720bd55e0d81a4da5c"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7981d274ae2e1d720bd55e0d81a4da5c">xkb_state::xkb_state_new</a> (struct <a class="el" href="structxkb__keymap.html">xkb_keymap</a> *keymap)</td></tr>
<tr class="separator:ga7981d274ae2e1d720bd55e0d81a4da5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc6924fdc5dd71d5cd4cd8ca962a072" id="r_gaedc6924fdc5dd71d5cd4cd8ca962a072"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaedc6924fdc5dd71d5cd4cd8ca962a072">xkb_state::xkb_state_ref</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state)</td></tr>
<tr class="separator:gaedc6924fdc5dd71d5cd4cd8ca962a072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f905c1383b32dcceb5feb9b9fdd0ce4" id="r_ga3f905c1383b32dcceb5feb9b9fdd0ce4"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f905c1383b32dcceb5feb9b9fdd0ce4">xkb_state::xkb_state_unref</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state)</td></tr>
<tr class="separator:ga3f905c1383b32dcceb5feb9b9fdd0ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae236241264c2b4b4a21d155019b154d7" id="r_gae236241264c2b4b4a21d155019b154d7"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT struct <a class="el" href="structxkb__keymap.html">xkb_keymap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae236241264c2b4b4a21d155019b154d7">xkb_state::xkb_state_get_keymap</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state)</td></tr>
<tr class="separator:gae236241264c2b4b4a21d155019b154d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3134cc3645cea6063bfb7e27d9a24d58" id="r_ga3134cc3645cea6063bfb7e27d9a24d58"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3134cc3645cea6063bfb7e27d9a24d58">xkb_state::xkb_state_update_key</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, enum <a class="el" href="#ga631f03db07f30774659ab3f787b152e7">xkb_key_direction</a> direction)</td></tr>
<tr class="separator:ga3134cc3645cea6063bfb7e27d9a24d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4566e39cb6fc96a59a86221a0546ea6" id="r_gab4566e39cb6fc96a59a86221a0546ea6"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab4566e39cb6fc96a59a86221a0546ea6">xkb_state::xkb_state_update_latched_locked</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> affect_latched_mods, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> latched_mods, bool affect_latched_layout, int32_t latched_layout, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> affect_locked_mods, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> locked_mods, bool affect_locked_layout, int32_t locked_layout)</td></tr>
<tr class="separator:gab4566e39cb6fc96a59a86221a0546ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae59cdbcc380013e9f12db359728fa098" id="r_gae59cdbcc380013e9f12db359728fa098"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae59cdbcc380013e9f12db359728fa098">xkb_state::xkb_state_update_mask</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> depressed_mods, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> latched_mods, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> locked_mods, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> depressed_layout, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> latched_layout, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> locked_layout)</td></tr>
<tr class="separator:gae59cdbcc380013e9f12db359728fa098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf884599c359e0d2d051f157bacdf22bb" id="r_gaf884599c359e0d2d051f157bacdf22bb"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf884599c359e0d2d051f157bacdf22bb">xkb_state::xkb_state_key_get_syms</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, const <a class="el" href="group__keysyms.html#ga79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a> **syms_out)</td></tr>
<tr class="separator:gaf884599c359e0d2d051f157bacdf22bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a143166e60a0cbf919c1fc80929014" id="r_ga74a143166e60a0cbf919c1fc80929014"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga74a143166e60a0cbf919c1fc80929014">xkb_state::xkb_state_key_get_utf8</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, char *buffer, size_t size)</td></tr>
<tr class="separator:ga74a143166e60a0cbf919c1fc80929014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16c1f44020b7468cc53f8259f6f61a01" id="r_ga16c1f44020b7468cc53f8259f6f61a01"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga16c1f44020b7468cc53f8259f6f61a01">xkb_state::xkb_state_key_get_utf32</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key)</td></tr>
<tr class="separator:ga16c1f44020b7468cc53f8259f6f61a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdf6b10a2203c2144767621d5c230bd4" id="r_gafdf6b10a2203c2144767621d5c230bd4"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT <a class="el" href="group__keysyms.html#ga79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafdf6b10a2203c2144767621d5c230bd4">xkb_state::xkb_state_key_get_one_sym</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key)</td></tr>
<tr class="separator:gafdf6b10a2203c2144767621d5c230bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd62763913d5767ed0feff6016db613a" id="r_gafd62763913d5767ed0feff6016db613a"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafd62763913d5767ed0feff6016db613a">xkb_state::xkb_state_key_get_layout</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key)</td></tr>
<tr class="separator:gafd62763913d5767ed0feff6016db613a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d1c128c65206292778e56b9f8b03e6e" id="r_ga3d1c128c65206292778e56b9f8b03e6e"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT <a class="el" href="xkbcommon_8h.html#a7eb38bea2a311b6ff033816278d5bbea">xkb_level_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3d1c128c65206292778e56b9f8b03e6e">xkb_state::xkb_state_key_get_level</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> layout)</td></tr>
<tr class="separator:ga3d1c128c65206292778e56b9f8b03e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfdacf066f449b36550e366b398effb8" id="r_gacfdacf066f449b36550e366b398effb8"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacfdacf066f449b36550e366b398effb8">xkb_state::xkb_state_serialize_mods</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> components)</td></tr>
<tr class="separator:gacfdacf066f449b36550e366b398effb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f0ad8c2337d14bcd5c3431a6d1c01ad" id="r_ga0f0ad8c2337d14bcd5c3431a6d1c01ad"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0f0ad8c2337d14bcd5c3431a6d1c01ad">xkb_state::xkb_state_serialize_layout</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> components)</td></tr>
<tr class="separator:ga0f0ad8c2337d14bcd5c3431a6d1c01ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3333d98bf879f792aff2312b3d968dd3" id="r_ga3333d98bf879f792aff2312b3d968dd3"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3333d98bf879f792aff2312b3d968dd3">xkb_state::xkb_state_mod_name_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, const char *name, enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type)</td></tr>
<tr class="separator:ga3333d98bf879f792aff2312b3d968dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8761daa182b55464765a0945c38f90a6" id="r_ga8761daa182b55464765a0945c38f90a6"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8761daa182b55464765a0945c38f90a6">xkb_state::xkb_state_mod_names_are_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type, enum <a class="el" href="#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a> match,...)</td></tr>
<tr class="separator:ga8761daa182b55464765a0945c38f90a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa856e0ad47b0aaa0240a5afe9963f835" id="r_gaa856e0ad47b0aaa0240a5afe9963f835"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa856e0ad47b0aaa0240a5afe9963f835">xkb_state::xkb_state_mod_index_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a> idx, enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type)</td></tr>
<tr class="separator:gaa856e0ad47b0aaa0240a5afe9963f835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32f7fc9e7d1153ea755cf424d8dae502" id="r_ga32f7fc9e7d1153ea755cf424d8dae502"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga32f7fc9e7d1153ea755cf424d8dae502">xkb_state::xkb_state_mod_indices_are_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type, enum <a class="el" href="#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a> match,...)</td></tr>
<tr class="separator:ga32f7fc9e7d1153ea755cf424d8dae502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b4fb57a80351cad6f723282b205df6a" id="r_ga1b4fb57a80351cad6f723282b205df6a"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1b4fb57a80351cad6f723282b205df6a">xkb_state::xkb_state_key_get_consumed_mods2</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, enum <a class="el" href="#ga66c3ae7ebaf4ccd60e5dab61dc1c29fb">xkb_consumed_mode</a> mode)</td></tr>
<tr class="separator:ga1b4fb57a80351cad6f723282b205df6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79e9babefa0c66ca3e35763790eb3ee0" id="r_ga79e9babefa0c66ca3e35763790eb3ee0"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga79e9babefa0c66ca3e35763790eb3ee0">xkb_state::xkb_state_key_get_consumed_mods</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key)</td></tr>
<tr class="separator:ga79e9babefa0c66ca3e35763790eb3ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7f8fdce72eaec05a3aeb2ffc3298156" id="r_gae7f8fdce72eaec05a3aeb2ffc3298156"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae7f8fdce72eaec05a3aeb2ffc3298156">xkb_state::xkb_state_mod_index_is_consumed2</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, <a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a> idx, enum <a class="el" href="#ga66c3ae7ebaf4ccd60e5dab61dc1c29fb">xkb_consumed_mode</a> mode)</td></tr>
<tr class="separator:gae7f8fdce72eaec05a3aeb2ffc3298156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a3e39da4a7ac1362458bc9edb06cdd7" id="r_ga9a3e39da4a7ac1362458bc9edb06cdd7"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9a3e39da4a7ac1362458bc9edb06cdd7">xkb_state::xkb_state_mod_index_is_consumed</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, <a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a> idx)</td></tr>
<tr class="separator:ga9a3e39da4a7ac1362458bc9edb06cdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82c36de783b57e2320f07de5e12b014a" id="r_ga82c36de783b57e2320f07de5e12b014a"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga82c36de783b57e2320f07de5e12b014a">xkb_state::xkb_state_mod_mask_remove_consumed</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> mask)</td></tr>
<tr class="separator:ga82c36de783b57e2320f07de5e12b014a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe666bb45849ea814d396cd7325ce85" id="r_ga7fe666bb45849ea814d396cd7325ce85"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7fe666bb45849ea814d396cd7325ce85">xkb_state::xkb_state_layout_name_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, const char *name, enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type)</td></tr>
<tr class="separator:ga7fe666bb45849ea814d396cd7325ce85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41ad31101dec3cf33e324e34730c90dd" id="r_ga41ad31101dec3cf33e324e34730c90dd"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga41ad31101dec3cf33e324e34730c90dd">xkb_state::xkb_state_layout_index_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> idx, enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type)</td></tr>
<tr class="separator:ga41ad31101dec3cf33e324e34730c90dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e26cf6beb7478cf665e5d14419b38f8" id="r_ga3e26cf6beb7478cf665e5d14419b38f8"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3e26cf6beb7478cf665e5d14419b38f8">xkb_state::xkb_state_led_name_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, const char *name)</td></tr>
<tr class="separator:ga3e26cf6beb7478cf665e5d14419b38f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5322c5dc36103306abc25d09e673c06" id="r_gaa5322c5dc36103306abc25d09e673c06"><td class="memItemLeft" align="right" valign="top">XKB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa5322c5dc36103306abc25d09e673c06">xkb_state::xkb_state_led_index_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#af6e951bdbcba8fb7e2532a8ebc6c9c87">xkb_led_index_t</a> idx)</td></tr>
<tr class="separator:gaa5322c5dc36103306abc25d09e673c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Creating, destroying and manipulating keyboard state objects. </p>


<h3><a id="server-client-state" name="server-client-state"></a>Server State and Client State</h3><div class="textblock"><p></p>
<p>The <a class="el" href="structxkb__state.html" title="Opaque keyboard state object.">xkb_state</a> API is used by two distinct actors in most window-system architectures:</p>
<ol type="1">
<li><p class="startli">A <em>server</em> - for example, a Wayland compositor, an X11 server, an evdev listener.</p>
<p class="startli">Servers maintain the XKB state for a device according to input events from the device, such as key presses and releases, and out-of-band events from the user, like UI layout switchers.</p>
</li>
<li><p class="startli">A <em>client</em> - for example, a Wayland client, an X11 client.</p>
<p class="startli">Clients do not listen to input from the device; instead, whenever the server state changes, the server serializes the state and notifies the clients that the state has changed; the clients then update the state from the serialization.</p>
</li>
</ol>
<p>Some entry points in the <a class="el" href="structxkb__state.html" title="Opaque keyboard state object.">xkb_state</a> API are only meant for servers and some are only meant for clients, and the two should generally not be mixed.</p>
<p></p>
</div>

<h3><a id="consumed-modifiers" name="consumed-modifiers"></a>Consumed Modifiers</h3><div class="textblock"><p></p>
<p>Some functions, like <code><a class="el" href="#gaf884599c359e0d2d051f157bacdf22bb" title="Get the keysyms obtained from pressing a particular key in a given keyboard state.">xkb_state::xkb_state_key_get_syms()</a></code>, look at the state of the modifiers in the keymap and derive from it the correct shift level to use for the key. For example, in a US layout, pressing the key labeled <code>&lt;A&gt;</code> while the Shift modifier is active, generates the keysym <code>A</code>. In this case, the Shift modifier is said to be <em>consumed</em>. However, the Num Lock modifier does not affect this translation at all, even if it is active, so it is not consumed by this translation.</p>
<p>It may be desirable for some application to not reuse consumed modifiers for further processing, e.g. for hotkeys or keyboard shortcuts. To understand why, consider some requirements from a standard shortcut mechanism, and how they are implemented:</p>
<ol type="1">
<li>The shortcut’s modifiers must match exactly to the state. For example, it is possible to bind separate actions to <code>&lt;Alt&gt;&lt;Tab&gt;</code> and to <code>&lt;Alt&gt;&lt;Shift&gt;&lt;Tab&gt;</code>. Further, if only <code>&lt;Alt&gt;&lt;Tab&gt;</code> is bound to an action, pressing <code>&lt;Alt&gt;&lt;Shift&gt;&lt;Tab&gt;</code> should not trigger the shortcut. Effectively, this means that the modifiers are compared using the equality operator (<code>==</code>).</li>
<li>Only relevant modifiers are considered for the matching. For example, Caps Lock and Num Lock should not generally affect the matching, e.g. when matching <code>&lt;Alt&gt;&lt;Tab&gt;</code> against the state, it does not matter whether Num Lock is active or not. These relevant, or <em>significant</em>, modifiers usually include Alt, Control, Shift, Super and similar. Effectively, this means that non-significant modifiers are masked out, before doing the comparison as described above.</li>
<li>The matching must be independent of the layout/keymap. For example, the <code>&lt;Plus&gt;</code> (+) symbol is found on the first level on some layouts, but requires holding Shift on others. If you simply bind the action to the <code>&lt;Plus&gt;</code> keysym, it would work for the unshifted kind, but not for the others, because the match against Shift would fail. If you bind the action to <code>&lt;Shift&gt;&lt;Plus&gt;</code>, only the shifted kind would work. So what is needed is to recognize that Shift is used up in the translation of the keysym itself, and therefore should not be included in the matching. Effectively, this means that consumed modifiers (Shift in this example) are masked out as well, before doing the comparison.</li>
</ol>
<p>In summary, this is approximately how the matching would be performed:</p>
<div class="fragment"><div class="line">(keysym == shortcut_keysym) &amp;&amp;</div>
<div class="line">((state_mods &amp; ~consumed_mods &amp; significant_mods) == shortcut_mods)</div>
</div><!-- fragment --><p><code>state_mods</code> are the modifiers reported by <code><a class="el" href="#gaa856e0ad47b0aaa0240a5afe9963f835" title="Test whether a modifier is active in a given keyboard state by index.">xkb_state::xkb_state_mod_index_is_active()</a></code> and similar functions. <code>consumed_mods</code> are the modifiers reported by <code><a class="el" href="#ga9a3e39da4a7ac1362458bc9edb06cdd7" title="Same as xkb_state_mod_index_is_consumed2() with mode ::XKB_CONSUMED_MOD_XKB.">xkb_state::xkb_state_mod_index_is_consumed()</a></code> and similar functions. <code>significant_mods</code> are decided upon by the application/toolkit/user; it is up to them to decide whether these are configurable or hard-coded.</p>
<p></p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga631f03db07f30774659ab3f787b152e7" name="ga631f03db07f30774659ab3f787b152e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga631f03db07f30774659ab3f787b152e7">&#9670;&#160;</a></span>xkb_key_direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga631f03db07f30774659ab3f787b152e7">xkb_key_direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the direction of the key (press / release). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga631f03db07f30774659ab3f787b152e7aa685cb474cd090014d1049f74c3e3ec5" name="gga631f03db07f30774659ab3f787b152e7aa685cb474cd090014d1049f74c3e3ec5"></a>XKB_KEY_UP&#160;</td><td class="fielddoc"><p>The key was released. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga631f03db07f30774659ab3f787b152e7a10b02b45f1fceae1b43bc69162f84678" name="gga631f03db07f30774659ab3f787b152e7a10b02b45f1fceae1b43bc69162f84678"></a>XKB_KEY_DOWN&#160;</td><td class="fielddoc"><p>The key was pressed. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga04e8eac0666cc64dee6f0d5a7a773a03" name="ga04e8eac0666cc64dee6f0d5a7a773a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04e8eac0666cc64dee6f0d5a7a773a03">&#9670;&#160;</a></span>xkb_state_component</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifier and layout types for state objects. </p>
<p>This enum is bitmaskable, e.g. (<code><a class="el" href="#gga04e8eac0666cc64dee6f0d5a7a773a03a82fc290363aaa579fa4957c7a72b8ce6" title="Depressed modifiers, i.e.">XKB_STATE_MODS_DEPRESSED</a></code> | <code><a class="el" href="#gga04e8eac0666cc64dee6f0d5a7a773a03af95b6c2b4979c32588abe8a960351434" title="Latched modifiers, i.e.">XKB_STATE_MODS_LATCHED</a></code>) is valid to exclude locked modifiers.</p>
<p>In XKB, the <code>DEPRESSED</code> components are also known as <em>base</em>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03a82fc290363aaa579fa4957c7a72b8ce6" name="gga04e8eac0666cc64dee6f0d5a7a773a03a82fc290363aaa579fa4957c7a72b8ce6"></a>XKB_STATE_MODS_DEPRESSED&#160;</td><td class="fielddoc"><p>Depressed modifiers, i.e. </p>
<p>a key is physically holding them. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03af95b6c2b4979c32588abe8a960351434" name="gga04e8eac0666cc64dee6f0d5a7a773a03af95b6c2b4979c32588abe8a960351434"></a>XKB_STATE_MODS_LATCHED&#160;</td><td class="fielddoc"><p>Latched modifiers, i.e. </p>
<p>will be unset after the next non-modifier key press. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03a95d6c496c78b6da162f7c78fbfc22bbc" name="gga04e8eac0666cc64dee6f0d5a7a773a03a95d6c496c78b6da162f7c78fbfc22bbc"></a>XKB_STATE_MODS_LOCKED&#160;</td><td class="fielddoc"><p>Locked modifiers, i.e. </p>
<p>will be unset after the key provoking the lock has been pressed again. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03a2357b9f2490e89ab2d549695ea49de4f" name="gga04e8eac0666cc64dee6f0d5a7a773a03a2357b9f2490e89ab2d549695ea49de4f"></a>XKB_STATE_MODS_EFFECTIVE&#160;</td><td class="fielddoc"><p>Effective modifiers, i.e. </p>
<p>currently active and affect key processing (derived from the other state components). Use this unless you explicitly care how the state came about. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03ae2030e8ff7db5ee988920633e2b08e88" name="gga04e8eac0666cc64dee6f0d5a7a773a03ae2030e8ff7db5ee988920633e2b08e88"></a>XKB_STATE_LAYOUT_DEPRESSED&#160;</td><td class="fielddoc"><p>Depressed layout, i.e. </p>
<p>a key is physically holding it. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03aaed45ef0bd8de351e096178c9b559345" name="gga04e8eac0666cc64dee6f0d5a7a773a03aaed45ef0bd8de351e096178c9b559345"></a>XKB_STATE_LAYOUT_LATCHED&#160;</td><td class="fielddoc"><p>Latched layout, i.e. </p>
<p>will be unset after the next non-modifier key press. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03a8b3f6503e09ad7a43a3be092cc7cfaca" name="gga04e8eac0666cc64dee6f0d5a7a773a03a8b3f6503e09ad7a43a3be092cc7cfaca"></a>XKB_STATE_LAYOUT_LOCKED&#160;</td><td class="fielddoc"><p>Locked layout, i.e. </p>
<p>will be unset after the key provoking the lock has been pressed again. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03a751a3a712f1a25225e13114266b29726" name="gga04e8eac0666cc64dee6f0d5a7a773a03a751a3a712f1a25225e13114266b29726"></a>XKB_STATE_LAYOUT_EFFECTIVE&#160;</td><td class="fielddoc"><p>Effective layout, i.e. </p>
<p>currently active and affects key processing (derived from the other state components). Use this unless you explicitly care how the state came about. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga04e8eac0666cc64dee6f0d5a7a773a03a9d22ee4abdad31a3e24afdede62c3c6d" name="gga04e8eac0666cc64dee6f0d5a7a773a03a9d22ee4abdad31a3e24afdede62c3c6d"></a>XKB_STATE_LEDS&#160;</td><td class="fielddoc"><p>LEDs (derived from the other state components). </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf79b475eb908309ae1aa0e231b2c9aa8" name="gaf79b475eb908309ae1aa0e231b2c9aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf79b475eb908309ae1aa0e231b2c9aa8">&#9670;&#160;</a></span>xkb_state_match</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match flags for <code><a class="el" href="#ga32f7fc9e7d1153ea755cf424d8dae502" title="Test whether a set of modifiers are active in a given keyboard state by index.">xkb_state::xkb_state_mod_indices_are_active()</a></code> and <code><a class="el" href="#ga8761daa182b55464765a0945c38f90a6" title="Test whether a set of modifiers are active in a given keyboard state by name.">xkb_state::xkb_state_mod_names_are_active()</a></code>, specifying the conditions for a successful match. </p>
<p><code><a class="el" href="#ggaf79b475eb908309ae1aa0e231b2c9aa8a4ae1c11ddb747718871afb24adbfb0d6" title="Makes matching non-exclusive, i.e.">XKB_STATE_MATCH_NON_EXCLUSIVE</a></code> is bitmaskable with the other modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf79b475eb908309ae1aa0e231b2c9aa8acc8bf019ef4abad1eff3762ab67fd1cf" name="ggaf79b475eb908309ae1aa0e231b2c9aa8acc8bf019ef4abad1eff3762ab67fd1cf"></a>XKB_STATE_MATCH_ANY&#160;</td><td class="fielddoc"><p>Returns true if any of the modifiers are active. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf79b475eb908309ae1aa0e231b2c9aa8a22afd2884474ad692b580a8b91413b5f" name="ggaf79b475eb908309ae1aa0e231b2c9aa8a22afd2884474ad692b580a8b91413b5f"></a>XKB_STATE_MATCH_ALL&#160;</td><td class="fielddoc"><p>Returns true if all of the modifiers are active. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf79b475eb908309ae1aa0e231b2c9aa8a4ae1c11ddb747718871afb24adbfb0d6" name="ggaf79b475eb908309ae1aa0e231b2c9aa8a4ae1c11ddb747718871afb24adbfb0d6"></a>XKB_STATE_MATCH_NON_EXCLUSIVE&#160;</td><td class="fielddoc"><p>Makes matching non-exclusive, i.e. </p>
<p>will not return false if a modifier not specified in the arguments is active. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga66c3ae7ebaf4ccd60e5dab61dc1c29fb" name="ga66c3ae7ebaf4ccd60e5dab61dc1c29fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66c3ae7ebaf4ccd60e5dab61dc1c29fb">&#9670;&#160;</a></span>xkb_consumed_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga66c3ae7ebaf4ccd60e5dab61dc1c29fb">xkb_consumed_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumed modifiers mode. </p>
<p>There are several possible methods for deciding which modifiers are consumed and which are not, each applicable for different systems or situations. The mode selects the method to use.</p>
<p>Keep in mind that in all methods, the keymap may decide to <em>preserve</em> a modifier, meaning it is not reported as consumed even if it would have otherwise. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga66c3ae7ebaf4ccd60e5dab61dc1c29fba14b9cdb7b905f3fdd7b0abcae2f597b1" name="gga66c3ae7ebaf4ccd60e5dab61dc1c29fba14b9cdb7b905f3fdd7b0abcae2f597b1"></a>XKB_CONSUMED_MODE_XKB&#160;</td><td class="fielddoc"><p>This is the mode defined in the XKB specification and used by libX11. </p>
<p>A modifier is consumed if and only if it <em>may affect</em> key translation.</p>
<p>For example, if <code>Control+Alt+&lt;Backspace&gt;</code> produces some assigned keysym, then when pressing just <code>&lt;Backspace&gt;</code>, <code>Control</code> and <code>Alt</code> are consumed, even though they are not active, since if they <em>were</em> active they would have affected key translation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga66c3ae7ebaf4ccd60e5dab61dc1c29fba5e01146412303501dc7db2c2cf5c48d4" name="gga66c3ae7ebaf4ccd60e5dab61dc1c29fba5e01146412303501dc7db2c2cf5c48d4"></a>XKB_CONSUMED_MODE_GTK&#160;</td><td class="fielddoc"><p>This is the mode used by the GTK+ toolkit. </p>
<p>The mode consists of the following two independent heuristics:</p>
<ul>
<li>The currently active set of modifiers, excluding modifiers which do not affect the key (as described for <a class="el" href="#gga66c3ae7ebaf4ccd60e5dab61dc1c29fba14b9cdb7b905f3fdd7b0abcae2f597b1">XKB_CONSUMED_MODE_XKB</a>), are considered consumed, if the keysyms produced when all of them are active are different from the keysyms produced when no modifiers are active.</li>
<li>A single modifier is considered consumed if the keysyms produced for the key when it is the only active modifier are different from the keysyms produced when no modifiers are active. </li>
</ul>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7981d274ae2e1d720bd55e0d81a4da5c" name="ga7981d274ae2e1d720bd55e0d81a4da5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7981d274ae2e1d720bd55e0d81a4da5c">&#9670;&#160;</a></span>xkb_state_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT struct <a class="el" href="structxkb__state.html">xkb_state</a> * xkb_state_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__keymap.html">xkb_keymap</a> *</td>          <td class="paramname"><span class="paramname"><em>keymap</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new keyboard state object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keymap</td><td>The keymap which the state will use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new keyboard state object, or <code>NULL</code> on failure. </dd></dl>

</div>
</div>
<a id="gaedc6924fdc5dd71d5cd4cd8ca962a072" name="gaedc6924fdc5dd71d5cd4cd8ca962a072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedc6924fdc5dd71d5cd4cd8ca962a072">&#9670;&#160;</a></span>xkb_state_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT struct <a class="el" href="structxkb__state.html">xkb_state</a> * xkb_state_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a new reference on a keyboard state object. </p>
<dl class="section return"><dt>Returns</dt><dd>The passed in object. </dd></dl>

</div>
</div>
<a id="ga3f905c1383b32dcceb5feb9b9fdd0ce4" name="ga3f905c1383b32dcceb5feb9b9fdd0ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f905c1383b32dcceb5feb9b9fdd0ce4">&#9670;&#160;</a></span>xkb_state_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT void xkb_state_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a reference on a keyboard state object, and possibly free it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state. If it is <code>NULL</code>, this function does nothing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae236241264c2b4b4a21d155019b154d7" name="gae236241264c2b4b4a21d155019b154d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae236241264c2b4b4a21d155019b154d7">&#9670;&#160;</a></span>xkb_state_get_keymap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT struct <a class="el" href="structxkb__keymap.html">xkb_keymap</a> * xkb_state_get_keymap </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the keymap which a keyboard state object is using. </p>
<dl class="section return"><dt>Returns</dt><dd>The keymap which was passed to <code><a class="el" href="#ga7981d274ae2e1d720bd55e0d81a4da5c" title="Create a new keyboard state object.">xkb_state_new()</a></code> when creating this state object.</dd></dl>
<p>This function does not take a new reference on the keymap; you must explicitly reference it yourself if you plan to use it beyond the lifetime of the state. </p>

</div>
</div>
<a id="ga3134cc3645cea6063bfb7e27d9a24d58" name="ga3134cc3645cea6063bfb7e27d9a24d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3134cc3645cea6063bfb7e27d9a24d58">&#9670;&#160;</a></span>xkb_state_update_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> xkb_state_update_key </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga631f03db07f30774659ab3f787b152e7">xkb_key_direction</a></td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the keyboard state to reflect a given key being pressed or released. </p>
<p>This entry point is intended for <em>server</em> applications and should not be used by <em>client</em> applications; see <a class="el" href="group__state.html">Server State and Client State</a> for details.</p>
<p>A series of calls to this function should be consistent; that is, a call with <code><a class="el" href="#gga631f03db07f30774659ab3f787b152e7a10b02b45f1fceae1b43bc69162f84678" title="The key was pressed.">XKB_KEY_DOWN</a></code> for a key should be matched by an <code><a class="el" href="#gga631f03db07f30774659ab3f787b152e7aa685cb474cd090014d1049f74c3e3ec5" title="The key was released.">XKB_KEY_UP</a></code>; if a key is pressed twice, it should be released twice; etc. Otherwise (e.g. due to missed input events), situations like “stuck modifiers” may occur.</p>
<p>This function is often used in conjunction with the function <code><a class="el" href="#gaf884599c359e0d2d051f157bacdf22bb" title="Get the keysyms obtained from pressing a particular key in a given keyboard state.">xkb_state_key_get_syms()</a></code> (or <code><a class="el" href="#gafdf6b10a2203c2144767621d5c230bd4" title="Get the single keysym obtained from pressing a particular key in a given keyboard state.">xkb_state_key_get_one_sym()</a></code>), for example, when handling a key event. In this case, you should prefer to get the keysyms <em>before</em> updating the key, such that the keysyms reported for the key event are not affected by the event itself. This is the conventional behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>A mask of state components that have changed as a result of the update. If nothing in the state has changed, returns 0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#gae59cdbcc380013e9f12db359728fa098" title="Update a keyboard state from a set of explicit masks.">xkb_state_update_mask()</a></code> </dd></dl>

</div>
</div>
<a id="gab4566e39cb6fc96a59a86221a0546ea6" name="gab4566e39cb6fc96a59a86221a0546ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4566e39cb6fc96a59a86221a0546ea6">&#9670;&#160;</a></span>xkb_state_update_latched_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> xkb_state_update_latched_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a></td>          <td class="paramname"><span class="paramname"><em>affect_latched_mods</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a></td>          <td class="paramname"><span class="paramname"><em>latched_mods</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>affect_latched_layout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>latched_layout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a></td>          <td class="paramname"><span class="paramname"><em>affect_locked_mods</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a></td>          <td class="paramname"><span class="paramname"><em>locked_mods</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>affect_locked_layout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>locked_layout</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the keyboard state to change the latched and locked state of the modifiers and layout. </p>
<p>This entry point is intended for <em>server</em> applications and should not be used by <em>client</em> applications; see <a class="el" href="group__state.html">Server State and Client State</a> for details.</p>
<p>Use this function to update the latched and locked state according to “out of band” (non-device) inputs, such as UI layout switchers.</p>
<dl class="section user"><dt>Layout out of range</dt><dd><p class="startdd"></p>
<p class="interdd">If the effective layout, after taking into account the depressed, latched and locked layout, is out of range (negative or greater than the maximum layout), it is brought into range. Currently, the layout is wrapped using integer modulus (with negative values wrapping from the end). The wrapping behavior may be made configurable in the future.</p>
<p class="enddd"></p>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state object. </td></tr>
    <tr><td class="paramname">affect_latched_mods</td><td></td></tr>
    <tr><td class="paramname">latched_mods</td><td>Modifiers to set as latched or unlatched. Only modifiers in <code class="param">affect_latched_mods</code> are considered. </td></tr>
    <tr><td class="paramname">affect_latched_layout</td><td></td></tr>
    <tr><td class="paramname">latched_layout</td><td>Layout to latch. Only considered if <code class="param">affect_latched_layout</code> is true. Maybe be out of range (including negative) &ndash; see note above. </td></tr>
    <tr><td class="paramname">affect_locked_mods</td><td></td></tr>
    <tr><td class="paramname">locked_mods</td><td>Modifiers to set as locked or unlocked. Only modifiers in <code class="param">affect_locked_mods</code> are considered. </td></tr>
    <tr><td class="paramname">affect_locked_layout</td><td></td></tr>
    <tr><td class="paramname">locked_layout</td><td>Layout to lock. Only considered if <code class="param">affect_locked_layout</code> is true. Maybe be out of range (including negative) &ndash; see note above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mask of state components that have changed as a result of the update. If nothing in the state has changed, returns 0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae59cdbcc380013e9f12db359728fa098" title="Update a keyboard state from a set of explicit masks.">xkb_state_update_mask()</a> </dd></dl>

</div>
</div>
<a id="gae59cdbcc380013e9f12db359728fa098" name="gae59cdbcc380013e9f12db359728fa098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae59cdbcc380013e9f12db359728fa098">&#9670;&#160;</a></span>xkb_state_update_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> xkb_state_update_mask </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a></td>          <td class="paramname"><span class="paramname"><em>depressed_mods</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a></td>          <td class="paramname"><span class="paramname"><em>latched_mods</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a></td>          <td class="paramname"><span class="paramname"><em>locked_mods</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a></td>          <td class="paramname"><span class="paramname"><em>depressed_layout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a></td>          <td class="paramname"><span class="paramname"><em>latched_layout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a></td>          <td class="paramname"><span class="paramname"><em>locked_layout</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a keyboard state from a set of explicit masks. </p>
<p>This entry point is intended for <em>client</em> applications; see <a class="el" href="group__state.html">Server State and Client State</a> for details. <em>Server</em> applications should use <code><a class="el" href="#ga3134cc3645cea6063bfb7e27d9a24d58" title="Update the keyboard state to reflect a given key being pressed or released.">xkb_state_update_key()</a></code> instead.</p>
<p>All parameters must always be passed, or the resulting state may be incoherent.</p>
<dl class="section warning"><dt>Warning</dt><dd>The serialization is lossy and will not survive round trips; it must only be used to feed client state objects, and must not be used to update the server state.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A mask of state components that have changed as a result of the update. If nothing in the state has changed, returns 0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03" title="Modifier and layout types for state objects.">xkb_state_component</a></code> </dd>
<dd>
<code><a class="el" href="#ga3134cc3645cea6063bfb7e27d9a24d58" title="Update the keyboard state to reflect a given key being pressed or released.">xkb_state_update_key()</a></code> </dd></dl>

</div>
</div>
<a id="gaf884599c359e0d2d051f157bacdf22bb" name="gaf884599c359e0d2d051f157bacdf22bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf884599c359e0d2d051f157bacdf22bb">&#9670;&#160;</a></span>xkb_state_key_get_syms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT int xkb_state_key_get_syms </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__keysyms.html#ga79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a> **</td>          <td class="paramname"><span class="paramname"><em>syms_out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the keysyms obtained from pressing a particular key in a given keyboard state. </p>
<p>Get the keysyms for a key according to the current active layout, modifiers and shift level for the key, as determined by a keyboard state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The keyboard state object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The keycode of the key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">syms_out</td><td>An immutable array of keysyms corresponding the key in the given keyboard state.</td></tr>
  </table>
  </dd>
</dl>
<p>As an extension to XKB, this function can return more than one keysym. If you do not want to handle this case, you can use <code><a class="el" href="#gafdf6b10a2203c2144767621d5c230bd4" title="Get the single keysym obtained from pressing a particular key in a given keyboard state.">xkb_state_key_get_one_sym()</a></code> for a simpler interface.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of keysyms in the syms_out array. If no keysyms are produced by the key in the given keyboard state, returns 0 and sets syms_out to <code>NULL</code>.</dd></dl>
<p>This function performs Capitalization <a class="el" href="group__keysyms.html">Keysym Transformations</a>.</p>
<dl class="section since"><dt>Since</dt><dd>1.9.0 This function now performs <a class="el" href="group__keysyms.html">Keysym Transformations</a>. </dd></dl>

</div>
</div>
<a id="ga74a143166e60a0cbf919c1fc80929014" name="ga74a143166e60a0cbf919c1fc80929014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74a143166e60a0cbf919c1fc80929014">&#9670;&#160;</a></span>xkb_state_key_get_utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT int xkb_state_key_get_utf8 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Unicode/UTF-8 string obtained from pressing a particular key in a given keyboard state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The keyboard state object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The keycode of the key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>A buffer to write the string into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the buffer passed is too small, the string is truncated (though still <code>NULL</code>-terminated).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes required for the string, excluding the <code>NULL</code> byte. If there is nothing to write, returns 0.</dd></dl>
<p>You may check if truncation has occurred by comparing the return value with the size of <code class="param">buffer</code>, similarly to the <code>snprintf(3)</code> function. You may safely pass <code>NULL</code> and 0 to <code class="param">buffer</code> and <code class="param">size</code> to find the required size (without the <code>NULL</code>-byte).</p>
<p>This function performs Capitalization and Control <a class="el" href="group__keysyms.html">Keysym Transformations</a>.</p>
<dl class="section since"><dt>Since</dt><dd>0.4.1 </dd></dl>

</div>
</div>
<a id="ga16c1f44020b7468cc53f8259f6f61a01" name="ga16c1f44020b7468cc53f8259f6f61a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16c1f44020b7468cc53f8259f6f61a01">&#9670;&#160;</a></span>xkb_state_key_get_utf32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT uint32_t xkb_state_key_get_utf32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Unicode/UTF-32 codepoint obtained from pressing a particular key in a a given keyboard state. </p>
<dl class="section return"><dt>Returns</dt><dd>The UTF-32 representation for the key, if it consists of only a single codepoint. Otherwise, returns 0.</dd></dl>
<p>This function performs Capitalization and Control <a class="el" href="group__keysyms.html">Keysym Transformations</a>.</p>
<dl class="section since"><dt>Since</dt><dd>0.4.1 </dd></dl>

</div>
</div>
<a id="gafdf6b10a2203c2144767621d5c230bd4" name="gafdf6b10a2203c2144767621d5c230bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdf6b10a2203c2144767621d5c230bd4">&#9670;&#160;</a></span>xkb_state_key_get_one_sym()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT <a class="el" href="group__keysyms.html#ga79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a> xkb_state_key_get_one_sym </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the single keysym obtained from pressing a particular key in a given keyboard state. </p>
<p>This function is similar to <code><a class="el" href="#gaf884599c359e0d2d051f157bacdf22bb" title="Get the keysyms obtained from pressing a particular key in a given keyboard state.">xkb_state_key_get_syms()</a></code>, but intended for users which cannot or do not want to handle the case where multiple keysyms are returned (in which case this function is preferred).</p>
<dl class="section return"><dt>Returns</dt><dd>The keysym. If the key does not have exactly one keysym, returns <code>XKB_KEY_NoSymbol</code>.</dd></dl>
<p>This function performs Capitalization <a class="el" href="group__keysyms.html">Keysym Transformations</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaf884599c359e0d2d051f157bacdf22bb" title="Get the keysyms obtained from pressing a particular key in a given keyboard state.">xkb_state_key_get_syms()</a> </dd></dl>

</div>
</div>
<a id="gafd62763913d5767ed0feff6016db613a" name="gafd62763913d5767ed0feff6016db613a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd62763913d5767ed0feff6016db613a">&#9670;&#160;</a></span>xkb_state_key_get_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> xkb_state_key_get_layout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the effective layout index for a key in a given keyboard state. </p>
<dl class="section return"><dt>Returns</dt><dd>The layout index for the key in the given keyboard state. If the given keycode is invalid, or if the key is not included in any layout at all, returns <code><a class="el" href="xkbcommon_8h.html#a028e8382ce57877f674e16895ff9a34a" title="Invalid layout index.">XKB_LAYOUT_INVALID</a></code>.</dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd>If the returned layout is valid, the following always holds: <div class="fragment"><div class="line"><a class="code hl_function" href="#gafd62763913d5767ed0feff6016db613a">xkb_state_key_get_layout</a>(state, key) &lt; xkb_keymap_num_layouts_for_key(keymap, key)</div>
<div class="ttc" id="agroup__state_html_gafd62763913d5767ed0feff6016db613a"><div class="ttname"><a href="#gafd62763913d5767ed0feff6016db613a">xkb_state::xkb_state_key_get_layout</a></div><div class="ttdeci">XKB_EXPORT xkb_layout_index_t xkb_state_key_get_layout(struct xkb_state *state, xkb_keycode_t key)</div><div class="ttdoc">Get the effective layout index for a key in a given keyboard state.</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga3d1c128c65206292778e56b9f8b03e6e" name="ga3d1c128c65206292778e56b9f8b03e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d1c128c65206292778e56b9f8b03e6e">&#9670;&#160;</a></span>xkb_state_key_get_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT <a class="el" href="xkbcommon_8h.html#a7eb38bea2a311b6ff033816278d5bbea">xkb_level_index_t</a> xkb_state_key_get_level </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a></td>          <td class="paramname"><span class="paramname"><em>layout</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the effective shift level for a key in a given keyboard state and layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">key</td><td>The keycode of the key. </td></tr>
    <tr><td class="paramname">layout</td><td>The layout for which to get the shift level. This must be smaller than: <div class="fragment"><div class="line">xkb_keymap_num_layouts_for_key(keymap, key) </div>
</div><!-- fragment --> usually it would be: <div class="fragment"><div class="line"><a class="code hl_function" href="#gafd62763913d5767ed0feff6016db613a">xkb_state_key_get_layout</a>(state, key) </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shift level index. If the key or layout are invalid, returns <code><a class="el" href="xkbcommon_8h.html#a9fb9cf8dc2c7635cc412cf121cd94b72" title="Invalid level index.">XKB_LEVEL_INVALID</a></code>.</dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd>If the returned level is valid, the following always holds: <div class="fragment"><div class="line"><a class="code hl_function" href="#ga3d1c128c65206292778e56b9f8b03e6e">xkb_state_key_get_level</a>(state, key, layout) &lt; xkb_keymap_num_levels_for_key(keymap, key, layout)</div>
<div class="ttc" id="agroup__state_html_ga3d1c128c65206292778e56b9f8b03e6e"><div class="ttname"><a href="#ga3d1c128c65206292778e56b9f8b03e6e">xkb_state::xkb_state_key_get_level</a></div><div class="ttdeci">XKB_EXPORT xkb_level_index_t xkb_state_key_get_level(struct xkb_state *state, xkb_keycode_t key, xkb_layout_index_t layout)</div><div class="ttdoc">Get the effective shift level for a key in a given keyboard state and layout.</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gacfdacf066f449b36550e366b398effb8" name="gacfdacf066f449b36550e366b398effb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfdacf066f449b36550e366b398effb8">&#9670;&#160;</a></span>xkb_state_serialize_mods()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> xkb_state_serialize_mods </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a></td>          <td class="paramname"><span class="paramname"><em>components</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The counterpart to <code><a class="el" href="#gae59cdbcc380013e9f12db359728fa098" title="Update a keyboard state from a set of explicit masks.">xkb_state::xkb_state_update_mask()</a></code> for modifiers, to be used on the server side of serialization. </p>
<p>This entry point is intended for <em>server</em> applications; see <a class="el" href="group__state.html">Server State and Client State</a> for details. <em>Client</em> applications should use the <code>xkb_state_mod_*_is_active</code> API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">components</td><td>A mask of the modifier state components to serialize. State components other than <code>XKB_STATE_MODS_*</code> are ignored. If <code><a class="el" href="#gga04e8eac0666cc64dee6f0d5a7a773a03a2357b9f2490e89ab2d549695ea49de4f" title="Effective modifiers, i.e.">XKB_STATE_MODS_EFFECTIVE</a></code> is included, all other state components are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8" title="A mask of modifier indices.">xkb_mod_mask_t</a></code> representing the given components of the modifier state. </dd></dl>

</div>
</div>
<a id="ga0f0ad8c2337d14bcd5c3431a6d1c01ad" name="ga0f0ad8c2337d14bcd5c3431a6d1c01ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f0ad8c2337d14bcd5c3431a6d1c01ad">&#9670;&#160;</a></span>xkb_state_serialize_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> xkb_state_serialize_layout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a></td>          <td class="paramname"><span class="paramname"><em>components</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The counterpart to <code><a class="el" href="#gae59cdbcc380013e9f12db359728fa098" title="Update a keyboard state from a set of explicit masks.">xkb_state::xkb_state_update_mask()</a></code> for layouts, to be used on the server side of serialization. </p>
<p>This entry point is intended for <em>server</em> applications; see <a class="el" href="group__state.html">Server State and Client State</a> for details. <em>Client</em> applications should use the xkb_state_layout_*_is_active API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">components</td><td>A mask of the layout state components to serialize. State components other than <code>XKB_STATE_LAYOUT_*</code> are ignored. If <code><a class="el" href="#gga04e8eac0666cc64dee6f0d5a7a773a03a751a3a712f1a25225e13114266b29726" title="Effective layout, i.e.">XKB_STATE_LAYOUT_EFFECTIVE</a></code> is included, all other state components are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A layout index representing the given components of the layout state. </dd></dl>

</div>
</div>
<a id="ga3333d98bf879f792aff2312b3d968dd3" name="ga3333d98bf879f792aff2312b3d968dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3333d98bf879f792aff2312b3d968dd3">&#9670;&#160;</a></span>xkb_state_mod_name_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT int xkb_state_mod_name_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a modifier is active in a given keyboard state by name. </p>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="keymap-text-format-v1-v2.html#virtual-modifier-def">virtual modifiers</a>, this function may <em>overmatch</em> in case there are virtual modifiers with overlapping mappings to <a class="el" href="keymap-text-format-v1-v2.html#real-modifier-def">real modifiers</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifier is active, 0 if it is not. If the modifier name does not exist in the keymap, returns -1.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.1.0: Works only with <em>real</em> modifiers </dd>
<dd>
1.8.0: Works also with <em>virtual</em> modifiers </dd></dl>

</div>
</div>
<a id="ga8761daa182b55464765a0945c38f90a6" name="ga8761daa182b55464765a0945c38f90a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8761daa182b55464765a0945c38f90a6">&#9670;&#160;</a></span>xkb_state_mod_names_are_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT int xkb_state_mod_names_are_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a></td>          <td class="paramname"><span class="paramname"><em>match</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a set of modifiers are active in a given keyboard state by name. </p>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="keymap-text-format-v1-v2.html#virtual-modifier-def">virtual modifiers</a>, this function may <em>overmatch</em> in case there are virtual modifiers with overlapping mappings to <a class="el" href="keymap-text-format-v1-v2.html#real-modifier-def">real modifiers</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">type</td><td>The component of the state against which to match the given modifiers. </td></tr>
    <tr><td class="paramname">match</td><td>The manner by which to match the state against the given modifiers. </td></tr>
    <tr><td class="paramname">...</td><td>The set of of modifier names to test, terminated by a NULL argument (sentinel).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifiers are active, 0 if they are not. If any of the modifier names do not exist in the keymap, returns -1.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.1.0: Works only with <em>real</em> modifiers </dd>
<dd>
1.8.0: Works also with <em>virtual</em> modifiers </dd></dl>

</div>
</div>
<a id="gaa856e0ad47b0aaa0240a5afe9963f835" name="gaa856e0ad47b0aaa0240a5afe9963f835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa856e0ad47b0aaa0240a5afe9963f835">&#9670;&#160;</a></span>xkb_state_mod_index_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT int xkb_state_mod_index_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a></td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a modifier is active in a given keyboard state by index. </p>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="keymap-text-format-v1-v2.html#virtual-modifier-def">virtual modifiers</a>, this function may <em>overmatch</em> in case there are virtual modifiers with overlapping mappings to <a class="el" href="keymap-text-format-v1-v2.html#real-modifier-def">real modifiers</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifier is active, 0 if it is not. If the modifier index is invalid in the keymap, returns -1.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.1.0: Works only with <em>real</em> modifiers </dd>
<dd>
1.8.0: Works also with <em>virtual</em> modifiers </dd></dl>

</div>
</div>
<a id="ga32f7fc9e7d1153ea755cf424d8dae502" name="ga32f7fc9e7d1153ea755cf424d8dae502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32f7fc9e7d1153ea755cf424d8dae502">&#9670;&#160;</a></span>xkb_state_mod_indices_are_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT int xkb_state_mod_indices_are_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a></td>          <td class="paramname"><span class="paramname"><em>match</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a set of modifiers are active in a given keyboard state by index. </p>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="keymap-text-format-v1-v2.html#virtual-modifier-def">virtual modifiers</a>, this function may <em>overmatch</em> in case there are virtual modifiers with overlapping mappings to <a class="el" href="keymap-text-format-v1-v2.html#real-modifier-def">real modifiers</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">type</td><td>The component of the state against which to match the given modifiers. </td></tr>
    <tr><td class="paramname">match</td><td>The manner by which to match the state against the given modifiers. </td></tr>
    <tr><td class="paramname">...</td><td>The set of of modifier indices to test, terminated by a <code><a class="el" href="xkbcommon_8h.html#aa212b715e867b6448848f4581d420873" title="Invalid modifier index.">XKB_MOD_INVALID</a></code> argument (sentinel).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifiers are active, 0 if they are not. If any of the modifier indices are invalid in the keymap, returns -1.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.1.0: Works only with <em>real</em> modifiers </dd>
<dd>
1.8.0: Works also with <em>virtual</em> modifiers </dd></dl>

</div>
</div>
<a id="ga1b4fb57a80351cad6f723282b205df6a" name="ga1b4fb57a80351cad6f723282b205df6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b4fb57a80351cad6f723282b205df6a">&#9670;&#160;</a></span>xkb_state_key_get_consumed_mods2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> xkb_state_key_get_consumed_mods2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga66c3ae7ebaf4ccd60e5dab61dc1c29fb">xkb_consumed_mode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mask of modifiers consumed by translating a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">key</td><td>The keycode of the key. </td></tr>
    <tr><td class="paramname">mode</td><td>The consumed modifiers mode to use; see enum description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mask of the consumed <a class="el" href="keymap-text-format-v1-v2.html#real-modifier-def">real modifiers</a> modifiers.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.7.0 </dd></dl>

</div>
</div>
<a id="ga79e9babefa0c66ca3e35763790eb3ee0" name="ga79e9babefa0c66ca3e35763790eb3ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79e9babefa0c66ca3e35763790eb3ee0">&#9670;&#160;</a></span>xkb_state_key_get_consumed_mods()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> xkb_state_key_get_consumed_mods </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code><a class="el" href="#ga1b4fb57a80351cad6f723282b205df6a" title="Get the mask of modifiers consumed by translating a given key.">xkb_state_key_get_consumed_mods2()</a></code> with mode <code><a class="el" href="#gga66c3ae7ebaf4ccd60e5dab61dc1c29fba14b9cdb7b905f3fdd7b0abcae2f597b1" title="This is the mode defined in the XKB specification and used by libX11.">XKB_CONSUMED_MODE_XKB</a></code>. </p>
<dl class="section since"><dt>Since</dt><dd>0.4.1 </dd></dl>

</div>
</div>
<a id="gae7f8fdce72eaec05a3aeb2ffc3298156" name="gae7f8fdce72eaec05a3aeb2ffc3298156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7f8fdce72eaec05a3aeb2ffc3298156">&#9670;&#160;</a></span>xkb_state_mod_index_is_consumed2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT int xkb_state_mod_index_is_consumed2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a></td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga66c3ae7ebaf4ccd60e5dab61dc1c29fb">xkb_consumed_mode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a modifier is consumed by keyboard state translation for a key. </p>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="keymap-text-format-v1-v2.html#virtual-modifier-def">virtual modifiers</a>, this function may <em>overmatch</em> in case there are virtual modifiers with overlapping mappings to <a class="el" href="keymap-text-format-v1-v2.html#real-modifier-def">real modifiers</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">key</td><td>The keycode of the key. </td></tr>
    <tr><td class="paramname">idx</td><td>The index of the modifier to check. </td></tr>
    <tr><td class="paramname">mode</td><td>The consumed modifiers mode to use; see enum description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifier is consumed, 0 if it is not. If the modifier index is not valid in the keymap, returns -1.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga82c36de783b57e2320f07de5e12b014a" title="Remove consumed modifiers from a modifier mask for a key.">xkb_state_mod_mask_remove_consumed()</a> </dd>
<dd>
<a class="el" href="#ga79e9babefa0c66ca3e35763790eb3ee0" title="Same as xkb_state_key_get_consumed_mods2() with mode XKB_CONSUMED_MODE_XKB.">xkb_state_key_get_consumed_mods()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.7.0: Works only with <em>real</em> modifiers </dd>
<dd>
1.8.0: Works also with <em>virtual</em> modifiers </dd></dl>

</div>
</div>
<a id="ga9a3e39da4a7ac1362458bc9edb06cdd7" name="ga9a3e39da4a7ac1362458bc9edb06cdd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a3e39da4a7ac1362458bc9edb06cdd7">&#9670;&#160;</a></span>xkb_state_mod_index_is_consumed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT int xkb_state_mod_index_is_consumed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a></td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code><a class="el" href="#gae7f8fdce72eaec05a3aeb2ffc3298156" title="Test whether a modifier is consumed by keyboard state translation for a key.">xkb_state_mod_index_is_consumed2()</a></code> with mode <code>::XKB_CONSUMED_MOD_XKB</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="keymap-text-format-v1-v2.html#virtual-modifier-def">virtual modifiers</a>, this function may <em>overmatch</em> in case there are virtual modifiers with overlapping mappings to <a class="el" href="keymap-text-format-v1-v2.html#real-modifier-def">real modifiers</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.4.1: Works only with <em>real</em> modifiers </dd>
<dd>
1.8.0: Works also with <em>virtual</em> modifiers </dd></dl>

</div>
</div>
<a id="ga82c36de783b57e2320f07de5e12b014a" name="ga82c36de783b57e2320f07de5e12b014a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82c36de783b57e2320f07de5e12b014a">&#9670;&#160;</a></span>xkb_state_mod_mask_remove_consumed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> xkb_state_mod_mask_remove_consumed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove consumed modifiers from a modifier mask for a key. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated</a></b></dt><dd>Use <code><a class="el" href="#ga1b4fb57a80351cad6f723282b205df6a" title="Get the mask of modifiers consumed by translating a given key.">xkb_state_key_get_consumed_mods2()</a></code> instead.</dd></dl>
<p>Takes the given modifier mask, and removes all modifiers which are consumed for that particular key (as in <code><a class="el" href="#ga9a3e39da4a7ac1362458bc9edb06cdd7" title="Same as xkb_state_mod_index_is_consumed2() with mode ::XKB_CONSUMED_MOD_XKB.">xkb_state_mod_index_is_consumed()</a></code>).</p>
<dl class="section return"><dt>Returns</dt><dd>a mask of <a class="el" href="keymap-text-format-v1-v2.html#real-modifier-def">real modifiers</a> modifiers.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga9a3e39da4a7ac1362458bc9edb06cdd7" title="Same as xkb_state_mod_index_is_consumed2() with mode ::XKB_CONSUMED_MOD_XKB.">xkb_state_mod_index_is_consumed()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.5.0: Works only with <em>real</em> modifiers </dd>
<dd>
1.8.0: Works also with <em>virtual</em> modifiers </dd></dl>

</div>
</div>
<a id="ga7fe666bb45849ea814d396cd7325ce85" name="ga7fe666bb45849ea814d396cd7325ce85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fe666bb45849ea814d396cd7325ce85">&#9670;&#160;</a></span>xkb_state_layout_name_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT int xkb_state_layout_name_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a layout is active in a given keyboard state by name. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the layout is active, 0 if it is not. If no layout with this name exists in the keymap, return -1.</dd></dl>
<p>If multiple layouts in the keymap have this name, the one with the lowest index is tested.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39" title="Index of a keyboard layout.">xkb_layout_index_t</a> </dd></dl>

</div>
</div>
<a id="ga41ad31101dec3cf33e324e34730c90dd" name="ga41ad31101dec3cf33e324e34730c90dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41ad31101dec3cf33e324e34730c90dd">&#9670;&#160;</a></span>xkb_state_layout_index_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT int xkb_state_layout_index_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a></td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a layout is active in a given keyboard state by index. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the layout is active, 0 if it is not. If the layout index is not valid in the keymap, returns -1.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39" title="Index of a keyboard layout.">xkb_layout_index_t</a> </dd></dl>

</div>
</div>
<a id="ga3e26cf6beb7478cf665e5d14419b38f8" name="ga3e26cf6beb7478cf665e5d14419b38f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e26cf6beb7478cf665e5d14419b38f8">&#9670;&#160;</a></span>xkb_state_led_name_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT int xkb_state_led_name_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a LED is active in a given keyboard state by name. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the LED is active, 0 if it not. If no LED with this name exists in the keymap, returns -1.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xkbcommon_8h.html#af6e951bdbcba8fb7e2532a8ebc6c9c87" title="Index of a keyboard LED.">xkb_led_index_t</a> </dd></dl>

</div>
</div>
<a id="gaa5322c5dc36103306abc25d09e673c06" name="gaa5322c5dc36103306abc25d09e673c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5322c5dc36103306abc25d09e673c06">&#9670;&#160;</a></span>xkb_state_led_index_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XKB_EXPORT int xkb_state_led_index_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#af6e951bdbcba8fb7e2532a8ebc6c9c87">xkb_led_index_t</a></td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a LED is active in a given keyboard state by index. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the LED is active, 0 if it not. If the LED index is not valid in the keymap, returns -1.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xkbcommon_8h.html#af6e951bdbcba8fb7e2532a8ebc6c9c87" title="Index of a keyboard LED.">xkb_led_index_t</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
